// Code generated by Prisma (prisma@1.27.4). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  contest: (where?: ContestWhereInput) => Promise<boolean>;
  contestProblem: (where?: ContestProblemWhereInput) => Promise<boolean>;
  discuss: (where?: DiscussWhereInput) => Promise<boolean>;
  discussChilder: (where?: DiscussChilderWhereInput) => Promise<boolean>;
  privilegeGroup: (where?: PrivilegeGroupWhereInput) => Promise<boolean>;
  problem: (where?: ProblemWhereInput) => Promise<boolean>;
  submit: (where?: SubmitWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userGroup: (where?: UserGroupWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  contest: (where: ContestWhereUniqueInput) => ContestPromise;
  contests: (
    args?: {
      where?: ContestWhereInput;
      orderBy?: ContestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Contest>;
  contestsConnection: (
    args?: {
      where?: ContestWhereInput;
      orderBy?: ContestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ContestConnectionPromise;
  contestProblem: (
    where: ContestProblemWhereUniqueInput
  ) => ContestProblemPromise;
  contestProblems: (
    args?: {
      where?: ContestProblemWhereInput;
      orderBy?: ContestProblemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ContestProblem>;
  contestProblemsConnection: (
    args?: {
      where?: ContestProblemWhereInput;
      orderBy?: ContestProblemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ContestProblemConnectionPromise;
  discuss: (where: DiscussWhereUniqueInput) => DiscussPromise;
  discusses: (
    args?: {
      where?: DiscussWhereInput;
      orderBy?: DiscussOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Discuss>;
  discussesConnection: (
    args?: {
      where?: DiscussWhereInput;
      orderBy?: DiscussOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DiscussConnectionPromise;
  discussChilder: (
    where: DiscussChilderWhereUniqueInput
  ) => DiscussChilderPromise;
  discussChilders: (
    args?: {
      where?: DiscussChilderWhereInput;
      orderBy?: DiscussChilderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<DiscussChilder>;
  discussChildersConnection: (
    args?: {
      where?: DiscussChilderWhereInput;
      orderBy?: DiscussChilderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DiscussChilderConnectionPromise;
  privilegeGroup: (
    where: PrivilegeGroupWhereUniqueInput
  ) => PrivilegeGroupPromise;
  privilegeGroups: (
    args?: {
      where?: PrivilegeGroupWhereInput;
      orderBy?: PrivilegeGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PrivilegeGroup>;
  privilegeGroupsConnection: (
    args?: {
      where?: PrivilegeGroupWhereInput;
      orderBy?: PrivilegeGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PrivilegeGroupConnectionPromise;
  problem: (where: ProblemWhereUniqueInput) => ProblemPromise;
  problems: (
    args?: {
      where?: ProblemWhereInput;
      orderBy?: ProblemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Problem>;
  problemsConnection: (
    args?: {
      where?: ProblemWhereInput;
      orderBy?: ProblemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProblemConnectionPromise;
  submit: (where: SubmitWhereUniqueInput) => SubmitPromise;
  submits: (
    args?: {
      where?: SubmitWhereInput;
      orderBy?: SubmitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Submit>;
  submitsConnection: (
    args?: {
      where?: SubmitWhereInput;
      orderBy?: SubmitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SubmitConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  userGroup: (where: UserGroupWhereUniqueInput) => UserGroupPromise;
  userGroups: (
    args?: {
      where?: UserGroupWhereInput;
      orderBy?: UserGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserGroup>;
  userGroupsConnection: (
    args?: {
      where?: UserGroupWhereInput;
      orderBy?: UserGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserGroupConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createContest: (data: ContestCreateInput) => ContestPromise;
  updateContest: (
    args: { data: ContestUpdateInput; where: ContestWhereUniqueInput }
  ) => ContestPromise;
  updateManyContests: (
    args: { data: ContestUpdateManyMutationInput; where?: ContestWhereInput }
  ) => BatchPayloadPromise;
  upsertContest: (
    args: {
      where: ContestWhereUniqueInput;
      create: ContestCreateInput;
      update: ContestUpdateInput;
    }
  ) => ContestPromise;
  deleteContest: (where: ContestWhereUniqueInput) => ContestPromise;
  deleteManyContests: (where?: ContestWhereInput) => BatchPayloadPromise;
  createContestProblem: (
    data: ContestProblemCreateInput
  ) => ContestProblemPromise;
  updateContestProblem: (
    args: {
      data: ContestProblemUpdateInput;
      where: ContestProblemWhereUniqueInput;
    }
  ) => ContestProblemPromise;
  updateManyContestProblems: (
    args: {
      data: ContestProblemUpdateManyMutationInput;
      where?: ContestProblemWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertContestProblem: (
    args: {
      where: ContestProblemWhereUniqueInput;
      create: ContestProblemCreateInput;
      update: ContestProblemUpdateInput;
    }
  ) => ContestProblemPromise;
  deleteContestProblem: (
    where: ContestProblemWhereUniqueInput
  ) => ContestProblemPromise;
  deleteManyContestProblems: (
    where?: ContestProblemWhereInput
  ) => BatchPayloadPromise;
  createDiscuss: (data: DiscussCreateInput) => DiscussPromise;
  updateDiscuss: (
    args: { data: DiscussUpdateInput; where: DiscussWhereUniqueInput }
  ) => DiscussPromise;
  updateManyDiscusses: (
    args: { data: DiscussUpdateManyMutationInput; where?: DiscussWhereInput }
  ) => BatchPayloadPromise;
  upsertDiscuss: (
    args: {
      where: DiscussWhereUniqueInput;
      create: DiscussCreateInput;
      update: DiscussUpdateInput;
    }
  ) => DiscussPromise;
  deleteDiscuss: (where: DiscussWhereUniqueInput) => DiscussPromise;
  deleteManyDiscusses: (where?: DiscussWhereInput) => BatchPayloadPromise;
  createDiscussChilder: (
    data: DiscussChilderCreateInput
  ) => DiscussChilderPromise;
  updateDiscussChilder: (
    args: {
      data: DiscussChilderUpdateInput;
      where: DiscussChilderWhereUniqueInput;
    }
  ) => DiscussChilderPromise;
  updateManyDiscussChilders: (
    args: {
      data: DiscussChilderUpdateManyMutationInput;
      where?: DiscussChilderWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertDiscussChilder: (
    args: {
      where: DiscussChilderWhereUniqueInput;
      create: DiscussChilderCreateInput;
      update: DiscussChilderUpdateInput;
    }
  ) => DiscussChilderPromise;
  deleteDiscussChilder: (
    where: DiscussChilderWhereUniqueInput
  ) => DiscussChilderPromise;
  deleteManyDiscussChilders: (
    where?: DiscussChilderWhereInput
  ) => BatchPayloadPromise;
  createPrivilegeGroup: (
    data: PrivilegeGroupCreateInput
  ) => PrivilegeGroupPromise;
  updatePrivilegeGroup: (
    args: {
      data: PrivilegeGroupUpdateInput;
      where: PrivilegeGroupWhereUniqueInput;
    }
  ) => PrivilegeGroupPromise;
  updateManyPrivilegeGroups: (
    args: {
      data: PrivilegeGroupUpdateManyMutationInput;
      where?: PrivilegeGroupWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPrivilegeGroup: (
    args: {
      where: PrivilegeGroupWhereUniqueInput;
      create: PrivilegeGroupCreateInput;
      update: PrivilegeGroupUpdateInput;
    }
  ) => PrivilegeGroupPromise;
  deletePrivilegeGroup: (
    where: PrivilegeGroupWhereUniqueInput
  ) => PrivilegeGroupPromise;
  deleteManyPrivilegeGroups: (
    where?: PrivilegeGroupWhereInput
  ) => BatchPayloadPromise;
  createProblem: (data: ProblemCreateInput) => ProblemPromise;
  updateProblem: (
    args: { data: ProblemUpdateInput; where: ProblemWhereUniqueInput }
  ) => ProblemPromise;
  updateManyProblems: (
    args: { data: ProblemUpdateManyMutationInput; where?: ProblemWhereInput }
  ) => BatchPayloadPromise;
  upsertProblem: (
    args: {
      where: ProblemWhereUniqueInput;
      create: ProblemCreateInput;
      update: ProblemUpdateInput;
    }
  ) => ProblemPromise;
  deleteProblem: (where: ProblemWhereUniqueInput) => ProblemPromise;
  deleteManyProblems: (where?: ProblemWhereInput) => BatchPayloadPromise;
  createSubmit: (data: SubmitCreateInput) => SubmitPromise;
  updateSubmit: (
    args: { data: SubmitUpdateInput; where: SubmitWhereUniqueInput }
  ) => SubmitPromise;
  updateManySubmits: (
    args: { data: SubmitUpdateManyMutationInput; where?: SubmitWhereInput }
  ) => BatchPayloadPromise;
  upsertSubmit: (
    args: {
      where: SubmitWhereUniqueInput;
      create: SubmitCreateInput;
      update: SubmitUpdateInput;
    }
  ) => SubmitPromise;
  deleteSubmit: (where: SubmitWhereUniqueInput) => SubmitPromise;
  deleteManySubmits: (where?: SubmitWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserGroup: (data: UserGroupCreateInput) => UserGroupPromise;
  updateUserGroup: (
    args: { data: UserGroupUpdateInput; where: UserGroupWhereUniqueInput }
  ) => UserGroupPromise;
  updateManyUserGroups: (
    args: {
      data: UserGroupUpdateManyMutationInput;
      where?: UserGroupWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserGroup: (
    args: {
      where: UserGroupWhereUniqueInput;
      create: UserGroupCreateInput;
      update: UserGroupUpdateInput;
    }
  ) => UserGroupPromise;
  deleteUserGroup: (where: UserGroupWhereUniqueInput) => UserGroupPromise;
  deleteManyUserGroups: (where?: UserGroupWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  contest: (
    where?: ContestSubscriptionWhereInput
  ) => ContestSubscriptionPayloadSubscription;
  contestProblem: (
    where?: ContestProblemSubscriptionWhereInput
  ) => ContestProblemSubscriptionPayloadSubscription;
  discuss: (
    where?: DiscussSubscriptionWhereInput
  ) => DiscussSubscriptionPayloadSubscription;
  discussChilder: (
    where?: DiscussChilderSubscriptionWhereInput
  ) => DiscussChilderSubscriptionPayloadSubscription;
  privilegeGroup: (
    where?: PrivilegeGroupSubscriptionWhereInput
  ) => PrivilegeGroupSubscriptionPayloadSubscription;
  problem: (
    where?: ProblemSubscriptionWhereInput
  ) => ProblemSubscriptionPayloadSubscription;
  submit: (
    where?: SubmitSubscriptionWhereInput
  ) => SubmitSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userGroup: (
    where?: UserGroupSubscriptionWhereInput
  ) => UserGroupSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PrivilegeGroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "privilege_ASC"
  | "privilege_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "password_ASC"
  | "password_DESC"
  | "level_ASC"
  | "level_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "submit_ASC"
  | "submit_DESC"
  | "solved_ASC"
  | "solved_DESC"
  | "accepted_ASC"
  | "accepted_DESC";

export type DiscussOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "contentRaw_ASC"
  | "contentRaw_DESC"
  | "content_ASC"
  | "content_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "userName_ASC"
  | "userName_DESC";

export type DiscussChilderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "contentRaw_ASC"
  | "contentRaw_DESC"
  | "content_ASC"
  | "content_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "userName_ASC"
  | "userName_DESC"
  | "replyUserId_ASC"
  | "replyUserId_DESC"
  | "replyUserName_ASC"
  | "replyUserName_DESC";

export type UserGroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type ContestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createUserName_ASC"
  | "createUserName_DESC"
  | "createUserId_ASC"
  | "createUserId_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC";

export type ContestProblemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "problemId_ASC"
  | "problemId_DESC"
  | "problemTitle_ASC"
  | "problemTitle_DESC"
  | "ac_ASC"
  | "ac_DESC"
  | "wa_ASC"
  | "wa_DESC";

export type ProblemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "status_ASC"
  | "status_DESC"
  | "type_ASC"
  | "type_DESC"
  | "tags_ASC"
  | "tags_DESC"
  | "title_ASC"
  | "title_DESC"
  | "describe_ASC"
  | "describe_DESC"
  | "inDescribe_ASC"
  | "inDescribe_DESC"
  | "outDescribe_ASC"
  | "outDescribe_DESC"
  | "inExample_ASC"
  | "inExample_DESC"
  | "outExample_ASC"
  | "outExample_DESC"
  | "hint_ASC"
  | "hint_DESC"
  | "source_ASC"
  | "source_DESC"
  | "example_ASC"
  | "example_DESC";

export type SubmitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "userName_ASC"
  | "userName_DESC"
  | "problemId_ASC"
  | "problemId_DESC"
  | "problemTitle_ASC"
  | "problemTitle_DESC"
  | "language_ASC"
  | "language_DESC"
  | "code_ASC"
  | "code_DESC"
  | "result_ASC"
  | "result_DESC"
  | "errorInfo_ASC"
  | "errorInfo_DESC"
  | "limitTime_ASC"
  | "limitTime_DESC"
  | "limitMemory_ASC"
  | "limitMemory_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ContestWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PrivilegeGroupWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  privilege?: Int;
  privilege_not?: Int;
  privilege_in?: Int[] | Int;
  privilege_not_in?: Int[] | Int;
  privilege_lt?: Int;
  privilege_lte?: Int;
  privilege_gt?: Int;
  privilege_gte?: Int;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  AND?: PrivilegeGroupWhereInput[] | PrivilegeGroupWhereInput;
  OR?: PrivilegeGroupWhereInput[] | PrivilegeGroupWhereInput;
  NOT?: PrivilegeGroupWhereInput[] | PrivilegeGroupWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  userId?: Int;
  userId_not?: Int;
  userId_in?: Int[] | Int;
  userId_not_in?: Int[] | Int;
  userId_lt?: Int;
  userId_lte?: Int;
  userId_gt?: Int;
  userId_gte?: Int;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  level?: Int;
  level_not?: Int;
  level_in?: Int[] | Int;
  level_not_in?: Int[] | Int;
  level_lt?: Int;
  level_lte?: Int;
  level_gt?: Int;
  level_gte?: Int;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  privilegeGroup_every?: PrivilegeGroupWhereInput;
  privilegeGroup_some?: PrivilegeGroupWhereInput;
  privilegeGroup_none?: PrivilegeGroupWhereInput;
  UserDiscuss_every?: DiscussWhereInput;
  UserDiscuss_some?: DiscussWhereInput;
  UserDiscuss_none?: DiscussWhereInput;
  UserDiscussChilder_every?: DiscussChilderWhereInput;
  UserDiscussChilder_some?: DiscussChilderWhereInput;
  UserDiscussChilder_none?: DiscussChilderWhereInput;
  userGroup_every?: UserGroupWhereInput;
  userGroup_some?: UserGroupWhereInput;
  userGroup_none?: UserGroupWhereInput;
  createUserGroup_every?: UserGroupWhereInput;
  createUserGroup_some?: UserGroupWhereInput;
  createUserGroup_none?: UserGroupWhereInput;
  privilegeUserGroup_every?: UserGroupWhereInput;
  privilegeUserGroup_some?: UserGroupWhereInput;
  privilegeUserGroup_none?: UserGroupWhereInput;
  submit?: Int;
  submit_not?: Int;
  submit_in?: Int[] | Int;
  submit_not_in?: Int[] | Int;
  submit_lt?: Int;
  submit_lte?: Int;
  submit_gt?: Int;
  submit_gte?: Int;
  solved?: Int;
  solved_not?: Int;
  solved_in?: Int[] | Int;
  solved_not_in?: Int[] | Int;
  solved_lt?: Int;
  solved_lte?: Int;
  solved_gt?: Int;
  solved_gte?: Int;
  accepted?: Int;
  accepted_not?: Int;
  accepted_in?: Int[] | Int;
  accepted_not_in?: Int[] | Int;
  accepted_lt?: Int;
  accepted_lte?: Int;
  accepted_gt?: Int;
  accepted_gte?: Int;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface DiscussWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  contentRaw?: String;
  contentRaw_not?: String;
  contentRaw_in?: String[] | String;
  contentRaw_not_in?: String[] | String;
  contentRaw_lt?: String;
  contentRaw_lte?: String;
  contentRaw_gt?: String;
  contentRaw_gte?: String;
  contentRaw_contains?: String;
  contentRaw_not_contains?: String;
  contentRaw_starts_with?: String;
  contentRaw_not_starts_with?: String;
  contentRaw_ends_with?: String;
  contentRaw_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  user?: UserWhereInput;
  userId?: Int;
  userId_not?: Int;
  userId_in?: Int[] | Int;
  userId_not_in?: Int[] | Int;
  userId_lt?: Int;
  userId_lte?: Int;
  userId_gt?: Int;
  userId_gte?: Int;
  userName?: String;
  userName_not?: String;
  userName_in?: String[] | String;
  userName_not_in?: String[] | String;
  userName_lt?: String;
  userName_lte?: String;
  userName_gt?: String;
  userName_gte?: String;
  userName_contains?: String;
  userName_not_contains?: String;
  userName_starts_with?: String;
  userName_not_starts_with?: String;
  userName_ends_with?: String;
  userName_not_ends_with?: String;
  children_every?: DiscussChilderWhereInput;
  children_some?: DiscussChilderWhereInput;
  children_none?: DiscussChilderWhereInput;
  AND?: DiscussWhereInput[] | DiscussWhereInput;
  OR?: DiscussWhereInput[] | DiscussWhereInput;
  NOT?: DiscussWhereInput[] | DiscussWhereInput;
}

export interface DiscussChilderWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  contentRaw?: String;
  contentRaw_not?: String;
  contentRaw_in?: String[] | String;
  contentRaw_not_in?: String[] | String;
  contentRaw_lt?: String;
  contentRaw_lte?: String;
  contentRaw_gt?: String;
  contentRaw_gte?: String;
  contentRaw_contains?: String;
  contentRaw_not_contains?: String;
  contentRaw_starts_with?: String;
  contentRaw_not_starts_with?: String;
  contentRaw_ends_with?: String;
  contentRaw_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  user?: UserWhereInput;
  userId?: Int;
  userId_not?: Int;
  userId_in?: Int[] | Int;
  userId_not_in?: Int[] | Int;
  userId_lt?: Int;
  userId_lte?: Int;
  userId_gt?: Int;
  userId_gte?: Int;
  userName?: String;
  userName_not?: String;
  userName_in?: String[] | String;
  userName_not_in?: String[] | String;
  userName_lt?: String;
  userName_lte?: String;
  userName_gt?: String;
  userName_gte?: String;
  userName_contains?: String;
  userName_not_contains?: String;
  userName_starts_with?: String;
  userName_not_starts_with?: String;
  userName_ends_with?: String;
  userName_not_ends_with?: String;
  replyUserId?: Int;
  replyUserId_not?: Int;
  replyUserId_in?: Int[] | Int;
  replyUserId_not_in?: Int[] | Int;
  replyUserId_lt?: Int;
  replyUserId_lte?: Int;
  replyUserId_gt?: Int;
  replyUserId_gte?: Int;
  replyUserName?: String;
  replyUserName_not?: String;
  replyUserName_in?: String[] | String;
  replyUserName_not_in?: String[] | String;
  replyUserName_lt?: String;
  replyUserName_lte?: String;
  replyUserName_gt?: String;
  replyUserName_gte?: String;
  replyUserName_contains?: String;
  replyUserName_not_contains?: String;
  replyUserName_starts_with?: String;
  replyUserName_not_starts_with?: String;
  replyUserName_ends_with?: String;
  replyUserName_not_ends_with?: String;
  AND?: DiscussChilderWhereInput[] | DiscussChilderWhereInput;
  OR?: DiscussChilderWhereInput[] | DiscussChilderWhereInput;
  NOT?: DiscussChilderWhereInput[] | DiscussChilderWhereInput;
}

export interface UserGroupWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  createUser?: UserWhereInput;
  privilege_every?: UserWhereInput;
  privilege_some?: UserWhereInput;
  privilege_none?: UserWhereInput;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  AND?: UserGroupWhereInput[] | UserGroupWhereInput;
  OR?: UserGroupWhereInput[] | UserGroupWhereInput;
  NOT?: UserGroupWhereInput[] | UserGroupWhereInput;
}

export interface ContestWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  type?: Int;
  type_not?: Int;
  type_in?: Int[] | Int;
  type_not_in?: Int[] | Int;
  type_lt?: Int;
  type_lte?: Int;
  type_gt?: Int;
  type_gte?: Int;
  createUserName?: String;
  createUserName_not?: String;
  createUserName_in?: String[] | String;
  createUserName_not_in?: String[] | String;
  createUserName_lt?: String;
  createUserName_lte?: String;
  createUserName_gt?: String;
  createUserName_gte?: String;
  createUserName_contains?: String;
  createUserName_not_contains?: String;
  createUserName_starts_with?: String;
  createUserName_not_starts_with?: String;
  createUserName_ends_with?: String;
  createUserName_not_ends_with?: String;
  createUserId?: Int;
  createUserId_not?: Int;
  createUserId_in?: Int[] | Int;
  createUserId_not_in?: Int[] | Int;
  createUserId_lt?: Int;
  createUserId_lte?: Int;
  createUserId_gt?: Int;
  createUserId_gte?: Int;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  endTime?: DateTimeInput;
  endTime_not?: DateTimeInput;
  endTime_in?: DateTimeInput[] | DateTimeInput;
  endTime_not_in?: DateTimeInput[] | DateTimeInput;
  endTime_lt?: DateTimeInput;
  endTime_lte?: DateTimeInput;
  endTime_gt?: DateTimeInput;
  endTime_gte?: DateTimeInput;
  userGroup?: UserGroupWhereInput;
  contestProblem?: ContestProblemWhereInput;
  AND?: ContestWhereInput[] | ContestWhereInput;
  OR?: ContestWhereInput[] | ContestWhereInput;
  NOT?: ContestWhereInput[] | ContestWhereInput;
}

export interface ContestProblemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  problem?: ProblemWhereInput;
  problemId?: String;
  problemId_not?: String;
  problemId_in?: String[] | String;
  problemId_not_in?: String[] | String;
  problemId_lt?: String;
  problemId_lte?: String;
  problemId_gt?: String;
  problemId_gte?: String;
  problemId_contains?: String;
  problemId_not_contains?: String;
  problemId_starts_with?: String;
  problemId_not_starts_with?: String;
  problemId_ends_with?: String;
  problemId_not_ends_with?: String;
  problemTitle?: String;
  problemTitle_not?: String;
  problemTitle_in?: String[] | String;
  problemTitle_not_in?: String[] | String;
  problemTitle_lt?: String;
  problemTitle_lte?: String;
  problemTitle_gt?: String;
  problemTitle_gte?: String;
  problemTitle_contains?: String;
  problemTitle_not_contains?: String;
  problemTitle_starts_with?: String;
  problemTitle_not_starts_with?: String;
  problemTitle_ends_with?: String;
  problemTitle_not_ends_with?: String;
  ac?: Int;
  ac_not?: Int;
  ac_in?: Int[] | Int;
  ac_not_in?: Int[] | Int;
  ac_lt?: Int;
  ac_lte?: Int;
  ac_gt?: Int;
  ac_gte?: Int;
  wa?: Int;
  wa_not?: Int;
  wa_in?: Int[] | Int;
  wa_not_in?: Int[] | Int;
  wa_lt?: Int;
  wa_lte?: Int;
  wa_gt?: Int;
  wa_gte?: Int;
  AND?: ContestProblemWhereInput[] | ContestProblemWhereInput;
  OR?: ContestProblemWhereInput[] | ContestProblemWhereInput;
  NOT?: ContestProblemWhereInput[] | ContestProblemWhereInput;
}

export interface ProblemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  status?: Int;
  status_not?: Int;
  status_in?: Int[] | Int;
  status_not_in?: Int[] | Int;
  status_lt?: Int;
  status_lte?: Int;
  status_gt?: Int;
  status_gte?: Int;
  type?: Int;
  type_not?: Int;
  type_in?: Int[] | Int;
  type_not_in?: Int[] | Int;
  type_lt?: Int;
  type_lte?: Int;
  type_gt?: Int;
  type_gte?: Int;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  describe?: String;
  describe_not?: String;
  describe_in?: String[] | String;
  describe_not_in?: String[] | String;
  describe_lt?: String;
  describe_lte?: String;
  describe_gt?: String;
  describe_gte?: String;
  describe_contains?: String;
  describe_not_contains?: String;
  describe_starts_with?: String;
  describe_not_starts_with?: String;
  describe_ends_with?: String;
  describe_not_ends_with?: String;
  inDescribe?: String;
  inDescribe_not?: String;
  inDescribe_in?: String[] | String;
  inDescribe_not_in?: String[] | String;
  inDescribe_lt?: String;
  inDescribe_lte?: String;
  inDescribe_gt?: String;
  inDescribe_gte?: String;
  inDescribe_contains?: String;
  inDescribe_not_contains?: String;
  inDescribe_starts_with?: String;
  inDescribe_not_starts_with?: String;
  inDescribe_ends_with?: String;
  inDescribe_not_ends_with?: String;
  outDescribe?: String;
  outDescribe_not?: String;
  outDescribe_in?: String[] | String;
  outDescribe_not_in?: String[] | String;
  outDescribe_lt?: String;
  outDescribe_lte?: String;
  outDescribe_gt?: String;
  outDescribe_gte?: String;
  outDescribe_contains?: String;
  outDescribe_not_contains?: String;
  outDescribe_starts_with?: String;
  outDescribe_not_starts_with?: String;
  outDescribe_ends_with?: String;
  outDescribe_not_ends_with?: String;
  inExample?: String;
  inExample_not?: String;
  inExample_in?: String[] | String;
  inExample_not_in?: String[] | String;
  inExample_lt?: String;
  inExample_lte?: String;
  inExample_gt?: String;
  inExample_gte?: String;
  inExample_contains?: String;
  inExample_not_contains?: String;
  inExample_starts_with?: String;
  inExample_not_starts_with?: String;
  inExample_ends_with?: String;
  inExample_not_ends_with?: String;
  outExample?: String;
  outExample_not?: String;
  outExample_in?: String[] | String;
  outExample_not_in?: String[] | String;
  outExample_lt?: String;
  outExample_lte?: String;
  outExample_gt?: String;
  outExample_gte?: String;
  outExample_contains?: String;
  outExample_not_contains?: String;
  outExample_starts_with?: String;
  outExample_not_starts_with?: String;
  outExample_ends_with?: String;
  outExample_not_ends_with?: String;
  hint?: String;
  hint_not?: String;
  hint_in?: String[] | String;
  hint_not_in?: String[] | String;
  hint_lt?: String;
  hint_lte?: String;
  hint_gt?: String;
  hint_gte?: String;
  hint_contains?: String;
  hint_not_contains?: String;
  hint_starts_with?: String;
  hint_not_starts_with?: String;
  hint_ends_with?: String;
  hint_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  example?: String;
  example_not?: String;
  example_in?: String[] | String;
  example_not_in?: String[] | String;
  example_lt?: String;
  example_lte?: String;
  example_gt?: String;
  example_gte?: String;
  example_contains?: String;
  example_not_contains?: String;
  example_starts_with?: String;
  example_not_starts_with?: String;
  example_ends_with?: String;
  example_not_ends_with?: String;
  discuss_every?: DiscussWhereInput;
  discuss_some?: DiscussWhereInput;
  discuss_none?: DiscussWhereInput;
  AND?: ProblemWhereInput[] | ProblemWhereInput;
  OR?: ProblemWhereInput[] | ProblemWhereInput;
  NOT?: ProblemWhereInput[] | ProblemWhereInput;
}

export type ContestProblemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type DiscussWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type DiscussChilderWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PrivilegeGroupWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ProblemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type SubmitWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SubmitWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  user?: UserWhereInput;
  userId?: Int;
  userId_not?: Int;
  userId_in?: Int[] | Int;
  userId_not_in?: Int[] | Int;
  userId_lt?: Int;
  userId_lte?: Int;
  userId_gt?: Int;
  userId_gte?: Int;
  userName?: String;
  userName_not?: String;
  userName_in?: String[] | String;
  userName_not_in?: String[] | String;
  userName_lt?: String;
  userName_lte?: String;
  userName_gt?: String;
  userName_gte?: String;
  userName_contains?: String;
  userName_not_contains?: String;
  userName_starts_with?: String;
  userName_not_starts_with?: String;
  userName_ends_with?: String;
  userName_not_ends_with?: String;
  problem?: ProblemWhereInput;
  problemId?: String;
  problemId_not?: String;
  problemId_in?: String[] | String;
  problemId_not_in?: String[] | String;
  problemId_lt?: String;
  problemId_lte?: String;
  problemId_gt?: String;
  problemId_gte?: String;
  problemId_contains?: String;
  problemId_not_contains?: String;
  problemId_starts_with?: String;
  problemId_not_starts_with?: String;
  problemId_ends_with?: String;
  problemId_not_ends_with?: String;
  problemTitle?: String;
  problemTitle_not?: String;
  problemTitle_in?: String[] | String;
  problemTitle_not_in?: String[] | String;
  problemTitle_lt?: String;
  problemTitle_lte?: String;
  problemTitle_gt?: String;
  problemTitle_gte?: String;
  problemTitle_contains?: String;
  problemTitle_not_contains?: String;
  problemTitle_starts_with?: String;
  problemTitle_not_starts_with?: String;
  problemTitle_ends_with?: String;
  problemTitle_not_ends_with?: String;
  language?: Int;
  language_not?: Int;
  language_in?: Int[] | Int;
  language_not_in?: Int[] | Int;
  language_lt?: Int;
  language_lte?: Int;
  language_gt?: Int;
  language_gte?: Int;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  result?: String;
  result_not?: String;
  result_in?: String[] | String;
  result_not_in?: String[] | String;
  result_lt?: String;
  result_lte?: String;
  result_gt?: String;
  result_gte?: String;
  result_contains?: String;
  result_not_contains?: String;
  result_starts_with?: String;
  result_not_starts_with?: String;
  result_ends_with?: String;
  result_not_ends_with?: String;
  errorInfo?: String;
  errorInfo_not?: String;
  errorInfo_in?: String[] | String;
  errorInfo_not_in?: String[] | String;
  errorInfo_lt?: String;
  errorInfo_lte?: String;
  errorInfo_gt?: String;
  errorInfo_gte?: String;
  errorInfo_contains?: String;
  errorInfo_not_contains?: String;
  errorInfo_starts_with?: String;
  errorInfo_not_starts_with?: String;
  errorInfo_ends_with?: String;
  errorInfo_not_ends_with?: String;
  contest?: ContestWhereInput;
  limitTime?: Int;
  limitTime_not?: Int;
  limitTime_in?: Int[] | Int;
  limitTime_not_in?: Int[] | Int;
  limitTime_lt?: Int;
  limitTime_lte?: Int;
  limitTime_gt?: Int;
  limitTime_gte?: Int;
  limitMemory?: Int;
  limitMemory_not?: Int;
  limitMemory_in?: Int[] | Int;
  limitMemory_not_in?: Int[] | Int;
  limitMemory_lt?: Int;
  limitMemory_lte?: Int;
  limitMemory_gt?: Int;
  limitMemory_gte?: Int;
  AND?: SubmitWhereInput[] | SubmitWhereInput;
  OR?: SubmitWhereInput[] | SubmitWhereInput;
  NOT?: SubmitWhereInput[] | SubmitWhereInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  userId?: Int;
}>;

export type UserGroupWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ContestCreateInput {
  name: String;
  type?: Int;
  createUserName: String;
  createUserId: Int;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  userGroup: UserGroupCreateOneInput;
  contestProblem: ContestProblemCreateOneInput;
}

export interface UserGroupCreateOneInput {
  create?: UserGroupCreateInput;
  connect?: UserGroupWhereUniqueInput;
}

export interface UserGroupCreateInput {
  name: String;
  createUser: UserCreateOneWithoutCreateUserGroupInput;
  privilege?: UserCreateManyInput;
  users?: UserCreateManyWithoutUserGroupInput;
}

export interface UserCreateOneWithoutCreateUserGroupInput {
  create?: UserCreateWithoutCreateUserGroupInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutCreateUserGroupInput {
  userId: Int;
  password: String;
  level?: Int;
  name: String;
  email?: String;
  privilegeGroup?: PrivilegeGroupCreateManyWithoutUsersInput;
  UserDiscuss?: DiscussCreateManyWithoutUserInput;
  UserDiscussChilder?: DiscussChilderCreateManyWithoutUserInput;
  userGroup?: UserGroupCreateManyWithoutUsersInput;
  privilegeUserGroup?: UserGroupCreateManyInput;
  problems?: UserCreateproblemsInput;
  submit?: Int;
  solved?: Int;
  accepted?: Int;
}

export interface PrivilegeGroupCreateManyWithoutUsersInput {
  create?:
    | PrivilegeGroupCreateWithoutUsersInput[]
    | PrivilegeGroupCreateWithoutUsersInput;
  connect?: PrivilegeGroupWhereUniqueInput[] | PrivilegeGroupWhereUniqueInput;
}

export interface PrivilegeGroupCreateWithoutUsersInput {
  name: String;
  privilege: Int;
}

export interface DiscussCreateManyWithoutUserInput {
  create?: DiscussCreateWithoutUserInput[] | DiscussCreateWithoutUserInput;
  connect?: DiscussWhereUniqueInput[] | DiscussWhereUniqueInput;
}

export interface DiscussCreateWithoutUserInput {
  contentRaw: String;
  content: String;
  userId: Int;
  userName: String;
  children?: DiscussChilderCreateManyInput;
}

export interface DiscussChilderCreateManyInput {
  create?: DiscussChilderCreateInput[] | DiscussChilderCreateInput;
  connect?: DiscussChilderWhereUniqueInput[] | DiscussChilderWhereUniqueInput;
}

export interface DiscussChilderCreateInput {
  contentRaw: String;
  content: String;
  user?: UserCreateOneWithoutUserDiscussChilderInput;
  userId: Int;
  userName: String;
  replyUserId: Int;
  replyUserName: String;
}

export interface UserCreateOneWithoutUserDiscussChilderInput {
  create?: UserCreateWithoutUserDiscussChilderInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutUserDiscussChilderInput {
  userId: Int;
  password: String;
  level?: Int;
  name: String;
  email?: String;
  privilegeGroup?: PrivilegeGroupCreateManyWithoutUsersInput;
  UserDiscuss?: DiscussCreateManyWithoutUserInput;
  userGroup?: UserGroupCreateManyWithoutUsersInput;
  createUserGroup?: UserGroupCreateManyWithoutCreateUserInput;
  privilegeUserGroup?: UserGroupCreateManyInput;
  problems?: UserCreateproblemsInput;
  submit?: Int;
  solved?: Int;
  accepted?: Int;
}

export interface UserGroupCreateManyWithoutUsersInput {
  create?:
    | UserGroupCreateWithoutUsersInput[]
    | UserGroupCreateWithoutUsersInput;
  connect?: UserGroupWhereUniqueInput[] | UserGroupWhereUniqueInput;
}

export interface UserGroupCreateWithoutUsersInput {
  name: String;
  createUser: UserCreateOneWithoutCreateUserGroupInput;
  privilege?: UserCreateManyInput;
}

export interface UserCreateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateInput {
  userId: Int;
  password: String;
  level?: Int;
  name: String;
  email?: String;
  privilegeGroup?: PrivilegeGroupCreateManyWithoutUsersInput;
  UserDiscuss?: DiscussCreateManyWithoutUserInput;
  UserDiscussChilder?: DiscussChilderCreateManyWithoutUserInput;
  userGroup?: UserGroupCreateManyWithoutUsersInput;
  createUserGroup?: UserGroupCreateManyWithoutCreateUserInput;
  privilegeUserGroup?: UserGroupCreateManyInput;
  problems?: UserCreateproblemsInput;
  submit?: Int;
  solved?: Int;
  accepted?: Int;
}

export interface DiscussChilderCreateManyWithoutUserInput {
  create?:
    | DiscussChilderCreateWithoutUserInput[]
    | DiscussChilderCreateWithoutUserInput;
  connect?: DiscussChilderWhereUniqueInput[] | DiscussChilderWhereUniqueInput;
}

export interface DiscussChilderCreateWithoutUserInput {
  contentRaw: String;
  content: String;
  userId: Int;
  userName: String;
  replyUserId: Int;
  replyUserName: String;
}

export interface UserGroupCreateManyWithoutCreateUserInput {
  create?:
    | UserGroupCreateWithoutCreateUserInput[]
    | UserGroupCreateWithoutCreateUserInput;
  connect?: UserGroupWhereUniqueInput[] | UserGroupWhereUniqueInput;
}

export interface UserGroupCreateWithoutCreateUserInput {
  name: String;
  privilege?: UserCreateManyInput;
  users?: UserCreateManyWithoutUserGroupInput;
}

export interface UserCreateManyWithoutUserGroupInput {
  create?: UserCreateWithoutUserGroupInput[] | UserCreateWithoutUserGroupInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutUserGroupInput {
  userId: Int;
  password: String;
  level?: Int;
  name: String;
  email?: String;
  privilegeGroup?: PrivilegeGroupCreateManyWithoutUsersInput;
  UserDiscuss?: DiscussCreateManyWithoutUserInput;
  UserDiscussChilder?: DiscussChilderCreateManyWithoutUserInput;
  createUserGroup?: UserGroupCreateManyWithoutCreateUserInput;
  privilegeUserGroup?: UserGroupCreateManyInput;
  problems?: UserCreateproblemsInput;
  submit?: Int;
  solved?: Int;
  accepted?: Int;
}

export interface UserGroupCreateManyInput {
  create?: UserGroupCreateInput[] | UserGroupCreateInput;
  connect?: UserGroupWhereUniqueInput[] | UserGroupWhereUniqueInput;
}

export interface UserCreateproblemsInput {
  set?: Json[] | Json;
}

export interface ContestProblemCreateOneInput {
  create?: ContestProblemCreateInput;
  connect?: ContestProblemWhereUniqueInput;
}

export interface ContestProblemCreateInput {
  problem?: ProblemCreateOneInput;
  problemId: String;
  problemTitle: String;
  ac?: Int;
  wa?: Int;
}

export interface ProblemCreateOneInput {
  create?: ProblemCreateInput;
  connect?: ProblemWhereUniqueInput;
}

export interface ProblemCreateInput {
  status?: Int;
  type?: Int;
  tags: Json;
  title: String;
  describe: String;
  inDescribe: String;
  outDescribe: String;
  inExample: String;
  outExample: String;
  hint?: String;
  source?: String;
  example?: String;
  discuss?: DiscussCreateManyInput;
}

export interface DiscussCreateManyInput {
  create?: DiscussCreateInput[] | DiscussCreateInput;
  connect?: DiscussWhereUniqueInput[] | DiscussWhereUniqueInput;
}

export interface DiscussCreateInput {
  contentRaw: String;
  content: String;
  user?: UserCreateOneWithoutUserDiscussInput;
  userId: Int;
  userName: String;
  children?: DiscussChilderCreateManyInput;
}

export interface UserCreateOneWithoutUserDiscussInput {
  create?: UserCreateWithoutUserDiscussInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutUserDiscussInput {
  userId: Int;
  password: String;
  level?: Int;
  name: String;
  email?: String;
  privilegeGroup?: PrivilegeGroupCreateManyWithoutUsersInput;
  UserDiscussChilder?: DiscussChilderCreateManyWithoutUserInput;
  userGroup?: UserGroupCreateManyWithoutUsersInput;
  createUserGroup?: UserGroupCreateManyWithoutCreateUserInput;
  privilegeUserGroup?: UserGroupCreateManyInput;
  problems?: UserCreateproblemsInput;
  submit?: Int;
  solved?: Int;
  accepted?: Int;
}

export interface ContestUpdateInput {
  name?: String;
  type?: Int;
  createUserName?: String;
  createUserId?: Int;
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  userGroup?: UserGroupUpdateOneRequiredInput;
  contestProblem?: ContestProblemUpdateOneRequiredInput;
}

export interface UserGroupUpdateOneRequiredInput {
  create?: UserGroupCreateInput;
  update?: UserGroupUpdateDataInput;
  upsert?: UserGroupUpsertNestedInput;
  connect?: UserGroupWhereUniqueInput;
}

export interface UserGroupUpdateDataInput {
  name?: String;
  createUser?: UserUpdateOneRequiredWithoutCreateUserGroupInput;
  privilege?: UserUpdateManyInput;
  users?: UserUpdateManyWithoutUserGroupInput;
}

export interface UserUpdateOneRequiredWithoutCreateUserGroupInput {
  create?: UserCreateWithoutCreateUserGroupInput;
  update?: UserUpdateWithoutCreateUserGroupDataInput;
  upsert?: UserUpsertWithoutCreateUserGroupInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutCreateUserGroupDataInput {
  userId?: Int;
  password?: String;
  level?: Int;
  name?: String;
  email?: String;
  privilegeGroup?: PrivilegeGroupUpdateManyWithoutUsersInput;
  UserDiscuss?: DiscussUpdateManyWithoutUserInput;
  UserDiscussChilder?: DiscussChilderUpdateManyWithoutUserInput;
  userGroup?: UserGroupUpdateManyWithoutUsersInput;
  privilegeUserGroup?: UserGroupUpdateManyInput;
  problems?: UserUpdateproblemsInput;
  submit?: Int;
  solved?: Int;
  accepted?: Int;
}

export interface PrivilegeGroupUpdateManyWithoutUsersInput {
  create?:
    | PrivilegeGroupCreateWithoutUsersInput[]
    | PrivilegeGroupCreateWithoutUsersInput;
  delete?: PrivilegeGroupWhereUniqueInput[] | PrivilegeGroupWhereUniqueInput;
  connect?: PrivilegeGroupWhereUniqueInput[] | PrivilegeGroupWhereUniqueInput;
  set?: PrivilegeGroupWhereUniqueInput[] | PrivilegeGroupWhereUniqueInput;
  disconnect?:
    | PrivilegeGroupWhereUniqueInput[]
    | PrivilegeGroupWhereUniqueInput;
  update?:
    | PrivilegeGroupUpdateWithWhereUniqueWithoutUsersInput[]
    | PrivilegeGroupUpdateWithWhereUniqueWithoutUsersInput;
  upsert?:
    | PrivilegeGroupUpsertWithWhereUniqueWithoutUsersInput[]
    | PrivilegeGroupUpsertWithWhereUniqueWithoutUsersInput;
  deleteMany?:
    | PrivilegeGroupScalarWhereInput[]
    | PrivilegeGroupScalarWhereInput;
  updateMany?:
    | PrivilegeGroupUpdateManyWithWhereNestedInput[]
    | PrivilegeGroupUpdateManyWithWhereNestedInput;
}

export interface PrivilegeGroupUpdateWithWhereUniqueWithoutUsersInput {
  where: PrivilegeGroupWhereUniqueInput;
  data: PrivilegeGroupUpdateWithoutUsersDataInput;
}

export interface PrivilegeGroupUpdateWithoutUsersDataInput {
  name?: String;
  privilege?: Int;
}

export interface PrivilegeGroupUpsertWithWhereUniqueWithoutUsersInput {
  where: PrivilegeGroupWhereUniqueInput;
  update: PrivilegeGroupUpdateWithoutUsersDataInput;
  create: PrivilegeGroupCreateWithoutUsersInput;
}

export interface PrivilegeGroupScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  privilege?: Int;
  privilege_not?: Int;
  privilege_in?: Int[] | Int;
  privilege_not_in?: Int[] | Int;
  privilege_lt?: Int;
  privilege_lte?: Int;
  privilege_gt?: Int;
  privilege_gte?: Int;
  AND?: PrivilegeGroupScalarWhereInput[] | PrivilegeGroupScalarWhereInput;
  OR?: PrivilegeGroupScalarWhereInput[] | PrivilegeGroupScalarWhereInput;
  NOT?: PrivilegeGroupScalarWhereInput[] | PrivilegeGroupScalarWhereInput;
}

export interface PrivilegeGroupUpdateManyWithWhereNestedInput {
  where: PrivilegeGroupScalarWhereInput;
  data: PrivilegeGroupUpdateManyDataInput;
}

export interface PrivilegeGroupUpdateManyDataInput {
  name?: String;
  privilege?: Int;
}

export interface DiscussUpdateManyWithoutUserInput {
  create?: DiscussCreateWithoutUserInput[] | DiscussCreateWithoutUserInput;
  delete?: DiscussWhereUniqueInput[] | DiscussWhereUniqueInput;
  connect?: DiscussWhereUniqueInput[] | DiscussWhereUniqueInput;
  set?: DiscussWhereUniqueInput[] | DiscussWhereUniqueInput;
  disconnect?: DiscussWhereUniqueInput[] | DiscussWhereUniqueInput;
  update?:
    | DiscussUpdateWithWhereUniqueWithoutUserInput[]
    | DiscussUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | DiscussUpsertWithWhereUniqueWithoutUserInput[]
    | DiscussUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: DiscussScalarWhereInput[] | DiscussScalarWhereInput;
  updateMany?:
    | DiscussUpdateManyWithWhereNestedInput[]
    | DiscussUpdateManyWithWhereNestedInput;
}

export interface DiscussUpdateWithWhereUniqueWithoutUserInput {
  where: DiscussWhereUniqueInput;
  data: DiscussUpdateWithoutUserDataInput;
}

export interface DiscussUpdateWithoutUserDataInput {
  contentRaw?: String;
  content?: String;
  userId?: Int;
  userName?: String;
  children?: DiscussChilderUpdateManyInput;
}

export interface DiscussChilderUpdateManyInput {
  create?: DiscussChilderCreateInput[] | DiscussChilderCreateInput;
  update?:
    | DiscussChilderUpdateWithWhereUniqueNestedInput[]
    | DiscussChilderUpdateWithWhereUniqueNestedInput;
  upsert?:
    | DiscussChilderUpsertWithWhereUniqueNestedInput[]
    | DiscussChilderUpsertWithWhereUniqueNestedInput;
  delete?: DiscussChilderWhereUniqueInput[] | DiscussChilderWhereUniqueInput;
  connect?: DiscussChilderWhereUniqueInput[] | DiscussChilderWhereUniqueInput;
  set?: DiscussChilderWhereUniqueInput[] | DiscussChilderWhereUniqueInput;
  disconnect?:
    | DiscussChilderWhereUniqueInput[]
    | DiscussChilderWhereUniqueInput;
  deleteMany?:
    | DiscussChilderScalarWhereInput[]
    | DiscussChilderScalarWhereInput;
  updateMany?:
    | DiscussChilderUpdateManyWithWhereNestedInput[]
    | DiscussChilderUpdateManyWithWhereNestedInput;
}

export interface DiscussChilderUpdateWithWhereUniqueNestedInput {
  where: DiscussChilderWhereUniqueInput;
  data: DiscussChilderUpdateDataInput;
}

export interface DiscussChilderUpdateDataInput {
  contentRaw?: String;
  content?: String;
  user?: UserUpdateOneWithoutUserDiscussChilderInput;
  userId?: Int;
  userName?: String;
  replyUserId?: Int;
  replyUserName?: String;
}

export interface UserUpdateOneWithoutUserDiscussChilderInput {
  create?: UserCreateWithoutUserDiscussChilderInput;
  update?: UserUpdateWithoutUserDiscussChilderDataInput;
  upsert?: UserUpsertWithoutUserDiscussChilderInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutUserDiscussChilderDataInput {
  userId?: Int;
  password?: String;
  level?: Int;
  name?: String;
  email?: String;
  privilegeGroup?: PrivilegeGroupUpdateManyWithoutUsersInput;
  UserDiscuss?: DiscussUpdateManyWithoutUserInput;
  userGroup?: UserGroupUpdateManyWithoutUsersInput;
  createUserGroup?: UserGroupUpdateManyWithoutCreateUserInput;
  privilegeUserGroup?: UserGroupUpdateManyInput;
  problems?: UserUpdateproblemsInput;
  submit?: Int;
  solved?: Int;
  accepted?: Int;
}

export interface UserGroupUpdateManyWithoutUsersInput {
  create?:
    | UserGroupCreateWithoutUsersInput[]
    | UserGroupCreateWithoutUsersInput;
  delete?: UserGroupWhereUniqueInput[] | UserGroupWhereUniqueInput;
  connect?: UserGroupWhereUniqueInput[] | UserGroupWhereUniqueInput;
  set?: UserGroupWhereUniqueInput[] | UserGroupWhereUniqueInput;
  disconnect?: UserGroupWhereUniqueInput[] | UserGroupWhereUniqueInput;
  update?:
    | UserGroupUpdateWithWhereUniqueWithoutUsersInput[]
    | UserGroupUpdateWithWhereUniqueWithoutUsersInput;
  upsert?:
    | UserGroupUpsertWithWhereUniqueWithoutUsersInput[]
    | UserGroupUpsertWithWhereUniqueWithoutUsersInput;
  deleteMany?: UserGroupScalarWhereInput[] | UserGroupScalarWhereInput;
  updateMany?:
    | UserGroupUpdateManyWithWhereNestedInput[]
    | UserGroupUpdateManyWithWhereNestedInput;
}

export interface UserGroupUpdateWithWhereUniqueWithoutUsersInput {
  where: UserGroupWhereUniqueInput;
  data: UserGroupUpdateWithoutUsersDataInput;
}

export interface UserGroupUpdateWithoutUsersDataInput {
  name?: String;
  createUser?: UserUpdateOneRequiredWithoutCreateUserGroupInput;
  privilege?: UserUpdateManyInput;
}

export interface UserUpdateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  update?:
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface UserUpdateDataInput {
  userId?: Int;
  password?: String;
  level?: Int;
  name?: String;
  email?: String;
  privilegeGroup?: PrivilegeGroupUpdateManyWithoutUsersInput;
  UserDiscuss?: DiscussUpdateManyWithoutUserInput;
  UserDiscussChilder?: DiscussChilderUpdateManyWithoutUserInput;
  userGroup?: UserGroupUpdateManyWithoutUsersInput;
  createUserGroup?: UserGroupUpdateManyWithoutCreateUserInput;
  privilegeUserGroup?: UserGroupUpdateManyInput;
  problems?: UserUpdateproblemsInput;
  submit?: Int;
  solved?: Int;
  accepted?: Int;
}

export interface DiscussChilderUpdateManyWithoutUserInput {
  create?:
    | DiscussChilderCreateWithoutUserInput[]
    | DiscussChilderCreateWithoutUserInput;
  delete?: DiscussChilderWhereUniqueInput[] | DiscussChilderWhereUniqueInput;
  connect?: DiscussChilderWhereUniqueInput[] | DiscussChilderWhereUniqueInput;
  set?: DiscussChilderWhereUniqueInput[] | DiscussChilderWhereUniqueInput;
  disconnect?:
    | DiscussChilderWhereUniqueInput[]
    | DiscussChilderWhereUniqueInput;
  update?:
    | DiscussChilderUpdateWithWhereUniqueWithoutUserInput[]
    | DiscussChilderUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | DiscussChilderUpsertWithWhereUniqueWithoutUserInput[]
    | DiscussChilderUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?:
    | DiscussChilderScalarWhereInput[]
    | DiscussChilderScalarWhereInput;
  updateMany?:
    | DiscussChilderUpdateManyWithWhereNestedInput[]
    | DiscussChilderUpdateManyWithWhereNestedInput;
}

export interface DiscussChilderUpdateWithWhereUniqueWithoutUserInput {
  where: DiscussChilderWhereUniqueInput;
  data: DiscussChilderUpdateWithoutUserDataInput;
}

export interface DiscussChilderUpdateWithoutUserDataInput {
  contentRaw?: String;
  content?: String;
  userId?: Int;
  userName?: String;
  replyUserId?: Int;
  replyUserName?: String;
}

export interface DiscussChilderUpsertWithWhereUniqueWithoutUserInput {
  where: DiscussChilderWhereUniqueInput;
  update: DiscussChilderUpdateWithoutUserDataInput;
  create: DiscussChilderCreateWithoutUserInput;
}

export interface DiscussChilderScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  contentRaw?: String;
  contentRaw_not?: String;
  contentRaw_in?: String[] | String;
  contentRaw_not_in?: String[] | String;
  contentRaw_lt?: String;
  contentRaw_lte?: String;
  contentRaw_gt?: String;
  contentRaw_gte?: String;
  contentRaw_contains?: String;
  contentRaw_not_contains?: String;
  contentRaw_starts_with?: String;
  contentRaw_not_starts_with?: String;
  contentRaw_ends_with?: String;
  contentRaw_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  userId?: Int;
  userId_not?: Int;
  userId_in?: Int[] | Int;
  userId_not_in?: Int[] | Int;
  userId_lt?: Int;
  userId_lte?: Int;
  userId_gt?: Int;
  userId_gte?: Int;
  userName?: String;
  userName_not?: String;
  userName_in?: String[] | String;
  userName_not_in?: String[] | String;
  userName_lt?: String;
  userName_lte?: String;
  userName_gt?: String;
  userName_gte?: String;
  userName_contains?: String;
  userName_not_contains?: String;
  userName_starts_with?: String;
  userName_not_starts_with?: String;
  userName_ends_with?: String;
  userName_not_ends_with?: String;
  replyUserId?: Int;
  replyUserId_not?: Int;
  replyUserId_in?: Int[] | Int;
  replyUserId_not_in?: Int[] | Int;
  replyUserId_lt?: Int;
  replyUserId_lte?: Int;
  replyUserId_gt?: Int;
  replyUserId_gte?: Int;
  replyUserName?: String;
  replyUserName_not?: String;
  replyUserName_in?: String[] | String;
  replyUserName_not_in?: String[] | String;
  replyUserName_lt?: String;
  replyUserName_lte?: String;
  replyUserName_gt?: String;
  replyUserName_gte?: String;
  replyUserName_contains?: String;
  replyUserName_not_contains?: String;
  replyUserName_starts_with?: String;
  replyUserName_not_starts_with?: String;
  replyUserName_ends_with?: String;
  replyUserName_not_ends_with?: String;
  AND?: DiscussChilderScalarWhereInput[] | DiscussChilderScalarWhereInput;
  OR?: DiscussChilderScalarWhereInput[] | DiscussChilderScalarWhereInput;
  NOT?: DiscussChilderScalarWhereInput[] | DiscussChilderScalarWhereInput;
}

export interface DiscussChilderUpdateManyWithWhereNestedInput {
  where: DiscussChilderScalarWhereInput;
  data: DiscussChilderUpdateManyDataInput;
}

export interface DiscussChilderUpdateManyDataInput {
  contentRaw?: String;
  content?: String;
  userId?: Int;
  userName?: String;
  replyUserId?: Int;
  replyUserName?: String;
}

export interface UserGroupUpdateManyWithoutCreateUserInput {
  create?:
    | UserGroupCreateWithoutCreateUserInput[]
    | UserGroupCreateWithoutCreateUserInput;
  delete?: UserGroupWhereUniqueInput[] | UserGroupWhereUniqueInput;
  connect?: UserGroupWhereUniqueInput[] | UserGroupWhereUniqueInput;
  set?: UserGroupWhereUniqueInput[] | UserGroupWhereUniqueInput;
  disconnect?: UserGroupWhereUniqueInput[] | UserGroupWhereUniqueInput;
  update?:
    | UserGroupUpdateWithWhereUniqueWithoutCreateUserInput[]
    | UserGroupUpdateWithWhereUniqueWithoutCreateUserInput;
  upsert?:
    | UserGroupUpsertWithWhereUniqueWithoutCreateUserInput[]
    | UserGroupUpsertWithWhereUniqueWithoutCreateUserInput;
  deleteMany?: UserGroupScalarWhereInput[] | UserGroupScalarWhereInput;
  updateMany?:
    | UserGroupUpdateManyWithWhereNestedInput[]
    | UserGroupUpdateManyWithWhereNestedInput;
}

export interface UserGroupUpdateWithWhereUniqueWithoutCreateUserInput {
  where: UserGroupWhereUniqueInput;
  data: UserGroupUpdateWithoutCreateUserDataInput;
}

export interface UserGroupUpdateWithoutCreateUserDataInput {
  name?: String;
  privilege?: UserUpdateManyInput;
  users?: UserUpdateManyWithoutUserGroupInput;
}

export interface UserUpdateManyWithoutUserGroupInput {
  create?: UserCreateWithoutUserGroupInput[] | UserCreateWithoutUserGroupInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutUserGroupInput[]
    | UserUpdateWithWhereUniqueWithoutUserGroupInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutUserGroupInput[]
    | UserUpsertWithWhereUniqueWithoutUserGroupInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutUserGroupInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutUserGroupDataInput;
}

export interface UserUpdateWithoutUserGroupDataInput {
  userId?: Int;
  password?: String;
  level?: Int;
  name?: String;
  email?: String;
  privilegeGroup?: PrivilegeGroupUpdateManyWithoutUsersInput;
  UserDiscuss?: DiscussUpdateManyWithoutUserInput;
  UserDiscussChilder?: DiscussChilderUpdateManyWithoutUserInput;
  createUserGroup?: UserGroupUpdateManyWithoutCreateUserInput;
  privilegeUserGroup?: UserGroupUpdateManyInput;
  problems?: UserUpdateproblemsInput;
  submit?: Int;
  solved?: Int;
  accepted?: Int;
}

export interface UserGroupUpdateManyInput {
  create?: UserGroupCreateInput[] | UserGroupCreateInput;
  update?:
    | UserGroupUpdateWithWhereUniqueNestedInput[]
    | UserGroupUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserGroupUpsertWithWhereUniqueNestedInput[]
    | UserGroupUpsertWithWhereUniqueNestedInput;
  delete?: UserGroupWhereUniqueInput[] | UserGroupWhereUniqueInput;
  connect?: UserGroupWhereUniqueInput[] | UserGroupWhereUniqueInput;
  set?: UserGroupWhereUniqueInput[] | UserGroupWhereUniqueInput;
  disconnect?: UserGroupWhereUniqueInput[] | UserGroupWhereUniqueInput;
  deleteMany?: UserGroupScalarWhereInput[] | UserGroupScalarWhereInput;
  updateMany?:
    | UserGroupUpdateManyWithWhereNestedInput[]
    | UserGroupUpdateManyWithWhereNestedInput;
}

export interface UserGroupUpdateWithWhereUniqueNestedInput {
  where: UserGroupWhereUniqueInput;
  data: UserGroupUpdateDataInput;
}

export interface UserGroupUpsertWithWhereUniqueNestedInput {
  where: UserGroupWhereUniqueInput;
  update: UserGroupUpdateDataInput;
  create: UserGroupCreateInput;
}

export interface UserGroupScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: UserGroupScalarWhereInput[] | UserGroupScalarWhereInput;
  OR?: UserGroupScalarWhereInput[] | UserGroupScalarWhereInput;
  NOT?: UserGroupScalarWhereInput[] | UserGroupScalarWhereInput;
}

export interface UserGroupUpdateManyWithWhereNestedInput {
  where: UserGroupScalarWhereInput;
  data: UserGroupUpdateManyDataInput;
}

export interface UserGroupUpdateManyDataInput {
  name?: String;
}

export interface UserUpdateproblemsInput {
  set?: Json[] | Json;
}

export interface UserUpsertWithWhereUniqueWithoutUserGroupInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutUserGroupDataInput;
  create: UserCreateWithoutUserGroupInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  userId?: Int;
  userId_not?: Int;
  userId_in?: Int[] | Int;
  userId_not_in?: Int[] | Int;
  userId_lt?: Int;
  userId_lte?: Int;
  userId_gt?: Int;
  userId_gte?: Int;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  level?: Int;
  level_not?: Int;
  level_in?: Int[] | Int;
  level_not_in?: Int[] | Int;
  level_lt?: Int;
  level_lte?: Int;
  level_gt?: Int;
  level_gte?: Int;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  submit?: Int;
  submit_not?: Int;
  submit_in?: Int[] | Int;
  submit_not_in?: Int[] | Int;
  submit_lt?: Int;
  submit_lte?: Int;
  submit_gt?: Int;
  submit_gte?: Int;
  solved?: Int;
  solved_not?: Int;
  solved_in?: Int[] | Int;
  solved_not_in?: Int[] | Int;
  solved_lt?: Int;
  solved_lte?: Int;
  solved_gt?: Int;
  solved_gte?: Int;
  accepted?: Int;
  accepted_not?: Int;
  accepted_in?: Int[] | Int;
  accepted_not_in?: Int[] | Int;
  accepted_lt?: Int;
  accepted_lte?: Int;
  accepted_gt?: Int;
  accepted_gte?: Int;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  userId?: Int;
  password?: String;
  level?: Int;
  name?: String;
  email?: String;
  problems?: UserUpdateproblemsInput;
  submit?: Int;
  solved?: Int;
  accepted?: Int;
}

export interface UserGroupUpsertWithWhereUniqueWithoutCreateUserInput {
  where: UserGroupWhereUniqueInput;
  update: UserGroupUpdateWithoutCreateUserDataInput;
  create: UserGroupCreateWithoutCreateUserInput;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface UserGroupUpsertWithWhereUniqueWithoutUsersInput {
  where: UserGroupWhereUniqueInput;
  update: UserGroupUpdateWithoutUsersDataInput;
  create: UserGroupCreateWithoutUsersInput;
}

export interface UserUpsertWithoutUserDiscussChilderInput {
  update: UserUpdateWithoutUserDiscussChilderDataInput;
  create: UserCreateWithoutUserDiscussChilderInput;
}

export interface DiscussChilderUpsertWithWhereUniqueNestedInput {
  where: DiscussChilderWhereUniqueInput;
  update: DiscussChilderUpdateDataInput;
  create: DiscussChilderCreateInput;
}

export interface DiscussUpsertWithWhereUniqueWithoutUserInput {
  where: DiscussWhereUniqueInput;
  update: DiscussUpdateWithoutUserDataInput;
  create: DiscussCreateWithoutUserInput;
}

export interface DiscussScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  contentRaw?: String;
  contentRaw_not?: String;
  contentRaw_in?: String[] | String;
  contentRaw_not_in?: String[] | String;
  contentRaw_lt?: String;
  contentRaw_lte?: String;
  contentRaw_gt?: String;
  contentRaw_gte?: String;
  contentRaw_contains?: String;
  contentRaw_not_contains?: String;
  contentRaw_starts_with?: String;
  contentRaw_not_starts_with?: String;
  contentRaw_ends_with?: String;
  contentRaw_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  userId?: Int;
  userId_not?: Int;
  userId_in?: Int[] | Int;
  userId_not_in?: Int[] | Int;
  userId_lt?: Int;
  userId_lte?: Int;
  userId_gt?: Int;
  userId_gte?: Int;
  userName?: String;
  userName_not?: String;
  userName_in?: String[] | String;
  userName_not_in?: String[] | String;
  userName_lt?: String;
  userName_lte?: String;
  userName_gt?: String;
  userName_gte?: String;
  userName_contains?: String;
  userName_not_contains?: String;
  userName_starts_with?: String;
  userName_not_starts_with?: String;
  userName_ends_with?: String;
  userName_not_ends_with?: String;
  AND?: DiscussScalarWhereInput[] | DiscussScalarWhereInput;
  OR?: DiscussScalarWhereInput[] | DiscussScalarWhereInput;
  NOT?: DiscussScalarWhereInput[] | DiscussScalarWhereInput;
}

export interface DiscussUpdateManyWithWhereNestedInput {
  where: DiscussScalarWhereInput;
  data: DiscussUpdateManyDataInput;
}

export interface DiscussUpdateManyDataInput {
  contentRaw?: String;
  content?: String;
  userId?: Int;
  userName?: String;
}

export interface UserUpsertWithoutCreateUserGroupInput {
  update: UserUpdateWithoutCreateUserGroupDataInput;
  create: UserCreateWithoutCreateUserGroupInput;
}

export interface UserGroupUpsertNestedInput {
  update: UserGroupUpdateDataInput;
  create: UserGroupCreateInput;
}

export interface ContestProblemUpdateOneRequiredInput {
  create?: ContestProblemCreateInput;
  update?: ContestProblemUpdateDataInput;
  upsert?: ContestProblemUpsertNestedInput;
  connect?: ContestProblemWhereUniqueInput;
}

export interface ContestProblemUpdateDataInput {
  problem?: ProblemUpdateOneInput;
  problemId?: String;
  problemTitle?: String;
  ac?: Int;
  wa?: Int;
}

export interface ProblemUpdateOneInput {
  create?: ProblemCreateInput;
  update?: ProblemUpdateDataInput;
  upsert?: ProblemUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProblemWhereUniqueInput;
}

export interface ProblemUpdateDataInput {
  status?: Int;
  type?: Int;
  tags?: Json;
  title?: String;
  describe?: String;
  inDescribe?: String;
  outDescribe?: String;
  inExample?: String;
  outExample?: String;
  hint?: String;
  source?: String;
  example?: String;
  discuss?: DiscussUpdateManyInput;
}

export interface DiscussUpdateManyInput {
  create?: DiscussCreateInput[] | DiscussCreateInput;
  update?:
    | DiscussUpdateWithWhereUniqueNestedInput[]
    | DiscussUpdateWithWhereUniqueNestedInput;
  upsert?:
    | DiscussUpsertWithWhereUniqueNestedInput[]
    | DiscussUpsertWithWhereUniqueNestedInput;
  delete?: DiscussWhereUniqueInput[] | DiscussWhereUniqueInput;
  connect?: DiscussWhereUniqueInput[] | DiscussWhereUniqueInput;
  set?: DiscussWhereUniqueInput[] | DiscussWhereUniqueInput;
  disconnect?: DiscussWhereUniqueInput[] | DiscussWhereUniqueInput;
  deleteMany?: DiscussScalarWhereInput[] | DiscussScalarWhereInput;
  updateMany?:
    | DiscussUpdateManyWithWhereNestedInput[]
    | DiscussUpdateManyWithWhereNestedInput;
}

export interface DiscussUpdateWithWhereUniqueNestedInput {
  where: DiscussWhereUniqueInput;
  data: DiscussUpdateDataInput;
}

export interface DiscussUpdateDataInput {
  contentRaw?: String;
  content?: String;
  user?: UserUpdateOneWithoutUserDiscussInput;
  userId?: Int;
  userName?: String;
  children?: DiscussChilderUpdateManyInput;
}

export interface UserUpdateOneWithoutUserDiscussInput {
  create?: UserCreateWithoutUserDiscussInput;
  update?: UserUpdateWithoutUserDiscussDataInput;
  upsert?: UserUpsertWithoutUserDiscussInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutUserDiscussDataInput {
  userId?: Int;
  password?: String;
  level?: Int;
  name?: String;
  email?: String;
  privilegeGroup?: PrivilegeGroupUpdateManyWithoutUsersInput;
  UserDiscussChilder?: DiscussChilderUpdateManyWithoutUserInput;
  userGroup?: UserGroupUpdateManyWithoutUsersInput;
  createUserGroup?: UserGroupUpdateManyWithoutCreateUserInput;
  privilegeUserGroup?: UserGroupUpdateManyInput;
  problems?: UserUpdateproblemsInput;
  submit?: Int;
  solved?: Int;
  accepted?: Int;
}

export interface UserUpsertWithoutUserDiscussInput {
  update: UserUpdateWithoutUserDiscussDataInput;
  create: UserCreateWithoutUserDiscussInput;
}

export interface DiscussUpsertWithWhereUniqueNestedInput {
  where: DiscussWhereUniqueInput;
  update: DiscussUpdateDataInput;
  create: DiscussCreateInput;
}

export interface ProblemUpsertNestedInput {
  update: ProblemUpdateDataInput;
  create: ProblemCreateInput;
}

export interface ContestProblemUpsertNestedInput {
  update: ContestProblemUpdateDataInput;
  create: ContestProblemCreateInput;
}

export interface ContestUpdateManyMutationInput {
  name?: String;
  type?: Int;
  createUserName?: String;
  createUserId?: Int;
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
}

export interface ContestProblemUpdateInput {
  problem?: ProblemUpdateOneInput;
  problemId?: String;
  problemTitle?: String;
  ac?: Int;
  wa?: Int;
}

export interface ContestProblemUpdateManyMutationInput {
  problemId?: String;
  problemTitle?: String;
  ac?: Int;
  wa?: Int;
}

export interface DiscussUpdateInput {
  contentRaw?: String;
  content?: String;
  user?: UserUpdateOneWithoutUserDiscussInput;
  userId?: Int;
  userName?: String;
  children?: DiscussChilderUpdateManyInput;
}

export interface DiscussUpdateManyMutationInput {
  contentRaw?: String;
  content?: String;
  userId?: Int;
  userName?: String;
}

export interface DiscussChilderUpdateInput {
  contentRaw?: String;
  content?: String;
  user?: UserUpdateOneWithoutUserDiscussChilderInput;
  userId?: Int;
  userName?: String;
  replyUserId?: Int;
  replyUserName?: String;
}

export interface DiscussChilderUpdateManyMutationInput {
  contentRaw?: String;
  content?: String;
  userId?: Int;
  userName?: String;
  replyUserId?: Int;
  replyUserName?: String;
}

export interface PrivilegeGroupCreateInput {
  name: String;
  privilege: Int;
  users?: UserCreateManyWithoutPrivilegeGroupInput;
}

export interface UserCreateManyWithoutPrivilegeGroupInput {
  create?:
    | UserCreateWithoutPrivilegeGroupInput[]
    | UserCreateWithoutPrivilegeGroupInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutPrivilegeGroupInput {
  userId: Int;
  password: String;
  level?: Int;
  name: String;
  email?: String;
  UserDiscuss?: DiscussCreateManyWithoutUserInput;
  UserDiscussChilder?: DiscussChilderCreateManyWithoutUserInput;
  userGroup?: UserGroupCreateManyWithoutUsersInput;
  createUserGroup?: UserGroupCreateManyWithoutCreateUserInput;
  privilegeUserGroup?: UserGroupCreateManyInput;
  problems?: UserCreateproblemsInput;
  submit?: Int;
  solved?: Int;
  accepted?: Int;
}

export interface PrivilegeGroupUpdateInput {
  name?: String;
  privilege?: Int;
  users?: UserUpdateManyWithoutPrivilegeGroupInput;
}

export interface UserUpdateManyWithoutPrivilegeGroupInput {
  create?:
    | UserCreateWithoutPrivilegeGroupInput[]
    | UserCreateWithoutPrivilegeGroupInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutPrivilegeGroupInput[]
    | UserUpdateWithWhereUniqueWithoutPrivilegeGroupInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutPrivilegeGroupInput[]
    | UserUpsertWithWhereUniqueWithoutPrivilegeGroupInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutPrivilegeGroupInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutPrivilegeGroupDataInput;
}

export interface UserUpdateWithoutPrivilegeGroupDataInput {
  userId?: Int;
  password?: String;
  level?: Int;
  name?: String;
  email?: String;
  UserDiscuss?: DiscussUpdateManyWithoutUserInput;
  UserDiscussChilder?: DiscussChilderUpdateManyWithoutUserInput;
  userGroup?: UserGroupUpdateManyWithoutUsersInput;
  createUserGroup?: UserGroupUpdateManyWithoutCreateUserInput;
  privilegeUserGroup?: UserGroupUpdateManyInput;
  problems?: UserUpdateproblemsInput;
  submit?: Int;
  solved?: Int;
  accepted?: Int;
}

export interface UserUpsertWithWhereUniqueWithoutPrivilegeGroupInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutPrivilegeGroupDataInput;
  create: UserCreateWithoutPrivilegeGroupInput;
}

export interface PrivilegeGroupUpdateManyMutationInput {
  name?: String;
  privilege?: Int;
}

export interface ProblemUpdateInput {
  status?: Int;
  type?: Int;
  tags?: Json;
  title?: String;
  describe?: String;
  inDescribe?: String;
  outDescribe?: String;
  inExample?: String;
  outExample?: String;
  hint?: String;
  source?: String;
  example?: String;
  discuss?: DiscussUpdateManyInput;
}

export interface ProblemUpdateManyMutationInput {
  status?: Int;
  type?: Int;
  tags?: Json;
  title?: String;
  describe?: String;
  inDescribe?: String;
  outDescribe?: String;
  inExample?: String;
  outExample?: String;
  hint?: String;
  source?: String;
  example?: String;
}

export interface SubmitCreateInput {
  user?: UserCreateOneInput;
  userId: Int;
  userName: String;
  problem?: ProblemCreateOneInput;
  problemId: String;
  problemTitle: String;
  language: Int;
  code: String;
  result: String;
  errorInfo?: String;
  contest?: ContestCreateOneInput;
  limitTime: Int;
  limitMemory: Int;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface ContestCreateOneInput {
  create?: ContestCreateInput;
  connect?: ContestWhereUniqueInput;
}

export interface SubmitUpdateInput {
  user?: UserUpdateOneInput;
  userId?: Int;
  userName?: String;
  problem?: ProblemUpdateOneInput;
  problemId?: String;
  problemTitle?: String;
  language?: Int;
  code?: String;
  result?: String;
  errorInfo?: String;
  contest?: ContestUpdateOneInput;
  limitTime?: Int;
  limitMemory?: Int;
}

export interface UserUpdateOneInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ContestUpdateOneInput {
  create?: ContestCreateInput;
  update?: ContestUpdateDataInput;
  upsert?: ContestUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ContestWhereUniqueInput;
}

export interface ContestUpdateDataInput {
  name?: String;
  type?: Int;
  createUserName?: String;
  createUserId?: Int;
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  userGroup?: UserGroupUpdateOneRequiredInput;
  contestProblem?: ContestProblemUpdateOneRequiredInput;
}

export interface ContestUpsertNestedInput {
  update: ContestUpdateDataInput;
  create: ContestCreateInput;
}

export interface SubmitUpdateManyMutationInput {
  userId?: Int;
  userName?: String;
  problemId?: String;
  problemTitle?: String;
  language?: Int;
  code?: String;
  result?: String;
  errorInfo?: String;
  limitTime?: Int;
  limitMemory?: Int;
}

export interface UserUpdateInput {
  userId?: Int;
  password?: String;
  level?: Int;
  name?: String;
  email?: String;
  privilegeGroup?: PrivilegeGroupUpdateManyWithoutUsersInput;
  UserDiscuss?: DiscussUpdateManyWithoutUserInput;
  UserDiscussChilder?: DiscussChilderUpdateManyWithoutUserInput;
  userGroup?: UserGroupUpdateManyWithoutUsersInput;
  createUserGroup?: UserGroupUpdateManyWithoutCreateUserInput;
  privilegeUserGroup?: UserGroupUpdateManyInput;
  problems?: UserUpdateproblemsInput;
  submit?: Int;
  solved?: Int;
  accepted?: Int;
}

export interface UserUpdateManyMutationInput {
  userId?: Int;
  password?: String;
  level?: Int;
  name?: String;
  email?: String;
  problems?: UserUpdateproblemsInput;
  submit?: Int;
  solved?: Int;
  accepted?: Int;
}

export interface UserGroupUpdateInput {
  name?: String;
  createUser?: UserUpdateOneRequiredWithoutCreateUserGroupInput;
  privilege?: UserUpdateManyInput;
  users?: UserUpdateManyWithoutUserGroupInput;
}

export interface UserGroupUpdateManyMutationInput {
  name?: String;
}

export interface ContestSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ContestWhereInput;
  AND?: ContestSubscriptionWhereInput[] | ContestSubscriptionWhereInput;
  OR?: ContestSubscriptionWhereInput[] | ContestSubscriptionWhereInput;
  NOT?: ContestSubscriptionWhereInput[] | ContestSubscriptionWhereInput;
}

export interface ContestProblemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ContestProblemWhereInput;
  AND?:
    | ContestProblemSubscriptionWhereInput[]
    | ContestProblemSubscriptionWhereInput;
  OR?:
    | ContestProblemSubscriptionWhereInput[]
    | ContestProblemSubscriptionWhereInput;
  NOT?:
    | ContestProblemSubscriptionWhereInput[]
    | ContestProblemSubscriptionWhereInput;
}

export interface DiscussSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DiscussWhereInput;
  AND?: DiscussSubscriptionWhereInput[] | DiscussSubscriptionWhereInput;
  OR?: DiscussSubscriptionWhereInput[] | DiscussSubscriptionWhereInput;
  NOT?: DiscussSubscriptionWhereInput[] | DiscussSubscriptionWhereInput;
}

export interface DiscussChilderSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DiscussChilderWhereInput;
  AND?:
    | DiscussChilderSubscriptionWhereInput[]
    | DiscussChilderSubscriptionWhereInput;
  OR?:
    | DiscussChilderSubscriptionWhereInput[]
    | DiscussChilderSubscriptionWhereInput;
  NOT?:
    | DiscussChilderSubscriptionWhereInput[]
    | DiscussChilderSubscriptionWhereInput;
}

export interface PrivilegeGroupSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PrivilegeGroupWhereInput;
  AND?:
    | PrivilegeGroupSubscriptionWhereInput[]
    | PrivilegeGroupSubscriptionWhereInput;
  OR?:
    | PrivilegeGroupSubscriptionWhereInput[]
    | PrivilegeGroupSubscriptionWhereInput;
  NOT?:
    | PrivilegeGroupSubscriptionWhereInput[]
    | PrivilegeGroupSubscriptionWhereInput;
}

export interface ProblemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProblemWhereInput;
  AND?: ProblemSubscriptionWhereInput[] | ProblemSubscriptionWhereInput;
  OR?: ProblemSubscriptionWhereInput[] | ProblemSubscriptionWhereInput;
  NOT?: ProblemSubscriptionWhereInput[] | ProblemSubscriptionWhereInput;
}

export interface SubmitSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SubmitWhereInput;
  AND?: SubmitSubscriptionWhereInput[] | SubmitSubscriptionWhereInput;
  OR?: SubmitSubscriptionWhereInput[] | SubmitSubscriptionWhereInput;
  NOT?: SubmitSubscriptionWhereInput[] | SubmitSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface UserGroupSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserGroupWhereInput;
  AND?: UserGroupSubscriptionWhereInput[] | UserGroupSubscriptionWhereInput;
  OR?: UserGroupSubscriptionWhereInput[] | UserGroupSubscriptionWhereInput;
  NOT?: UserGroupSubscriptionWhereInput[] | UserGroupSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Contest {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  type?: Int;
  createUserName: String;
  createUserId: Int;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
}

export interface ContestPromise extends Promise<Contest>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  type: () => Promise<Int>;
  createUserName: () => Promise<String>;
  createUserId: () => Promise<Int>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  userGroup: <T = UserGroupPromise>() => T;
  contestProblem: <T = ContestProblemPromise>() => T;
}

export interface ContestSubscription
  extends Promise<AsyncIterator<Contest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<Int>>;
  createUserName: () => Promise<AsyncIterator<String>>;
  createUserId: () => Promise<AsyncIterator<Int>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  userGroup: <T = UserGroupSubscription>() => T;
  contestProblem: <T = ContestProblemSubscription>() => T;
}

export interface UserGroup {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface UserGroupPromise extends Promise<UserGroup>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  createUser: <T = UserPromise>() => T;
  privilege: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserGroupSubscription
  extends Promise<AsyncIterator<UserGroup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  createUser: <T = UserSubscription>() => T;
  privilege: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  userId: Int;
  password: String;
  level: Int;
  name: String;
  email?: String;
  problems: Json[];
  submit: Int;
  solved: Int;
  accepted: Int;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<Int>;
  password: () => Promise<String>;
  level: () => Promise<Int>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  privilegeGroup: <T = FragmentableArray<PrivilegeGroup>>(
    args?: {
      where?: PrivilegeGroupWhereInput;
      orderBy?: PrivilegeGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  UserDiscuss: <T = FragmentableArray<Discuss>>(
    args?: {
      where?: DiscussWhereInput;
      orderBy?: DiscussOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  UserDiscussChilder: <T = FragmentableArray<DiscussChilder>>(
    args?: {
      where?: DiscussChilderWhereInput;
      orderBy?: DiscussChilderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  userGroup: <T = FragmentableArray<UserGroup>>(
    args?: {
      where?: UserGroupWhereInput;
      orderBy?: UserGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createUserGroup: <T = FragmentableArray<UserGroup>>(
    args?: {
      where?: UserGroupWhereInput;
      orderBy?: UserGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  privilegeUserGroup: <T = FragmentableArray<UserGroup>>(
    args?: {
      where?: UserGroupWhereInput;
      orderBy?: UserGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  problems: () => Promise<Json[]>;
  submit: () => Promise<Int>;
  solved: () => Promise<Int>;
  accepted: () => Promise<Int>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<Int>>;
  password: () => Promise<AsyncIterator<String>>;
  level: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  privilegeGroup: <T = Promise<AsyncIterator<PrivilegeGroupSubscription>>>(
    args?: {
      where?: PrivilegeGroupWhereInput;
      orderBy?: PrivilegeGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  UserDiscuss: <T = Promise<AsyncIterator<DiscussSubscription>>>(
    args?: {
      where?: DiscussWhereInput;
      orderBy?: DiscussOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  UserDiscussChilder: <T = Promise<AsyncIterator<DiscussChilderSubscription>>>(
    args?: {
      where?: DiscussChilderWhereInput;
      orderBy?: DiscussChilderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  userGroup: <T = Promise<AsyncIterator<UserGroupSubscription>>>(
    args?: {
      where?: UserGroupWhereInput;
      orderBy?: UserGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createUserGroup: <T = Promise<AsyncIterator<UserGroupSubscription>>>(
    args?: {
      where?: UserGroupWhereInput;
      orderBy?: UserGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  privilegeUserGroup: <T = Promise<AsyncIterator<UserGroupSubscription>>>(
    args?: {
      where?: UserGroupWhereInput;
      orderBy?: UserGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  problems: () => Promise<AsyncIterator<Json[]>>;
  submit: () => Promise<AsyncIterator<Int>>;
  solved: () => Promise<AsyncIterator<Int>>;
  accepted: () => Promise<AsyncIterator<Int>>;
}

export interface PrivilegeGroup {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  privilege: Int;
}

export interface PrivilegeGroupPromise
  extends Promise<PrivilegeGroup>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  privilege: () => Promise<Int>;
  users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PrivilegeGroupSubscription
  extends Promise<AsyncIterator<PrivilegeGroup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  privilege: () => Promise<AsyncIterator<Int>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Discuss {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  contentRaw: String;
  content: String;
  userId: Int;
  userName: String;
}

export interface DiscussPromise extends Promise<Discuss>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  contentRaw: () => Promise<String>;
  content: () => Promise<String>;
  user: <T = UserPromise>() => T;
  userId: () => Promise<Int>;
  userName: () => Promise<String>;
  children: <T = FragmentableArray<DiscussChilder>>(
    args?: {
      where?: DiscussChilderWhereInput;
      orderBy?: DiscussChilderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DiscussSubscription
  extends Promise<AsyncIterator<Discuss>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  contentRaw: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  userId: () => Promise<AsyncIterator<Int>>;
  userName: () => Promise<AsyncIterator<String>>;
  children: <T = Promise<AsyncIterator<DiscussChilderSubscription>>>(
    args?: {
      where?: DiscussChilderWhereInput;
      orderBy?: DiscussChilderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DiscussChilder {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  contentRaw: String;
  content: String;
  userId: Int;
  userName: String;
  replyUserId: Int;
  replyUserName: String;
}

export interface DiscussChilderPromise
  extends Promise<DiscussChilder>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  contentRaw: () => Promise<String>;
  content: () => Promise<String>;
  user: <T = UserPromise>() => T;
  userId: () => Promise<Int>;
  userName: () => Promise<String>;
  replyUserId: () => Promise<Int>;
  replyUserName: () => Promise<String>;
}

export interface DiscussChilderSubscription
  extends Promise<AsyncIterator<DiscussChilder>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  contentRaw: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  userId: () => Promise<AsyncIterator<Int>>;
  userName: () => Promise<AsyncIterator<String>>;
  replyUserId: () => Promise<AsyncIterator<Int>>;
  replyUserName: () => Promise<AsyncIterator<String>>;
}

export interface ContestProblem {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  problemId: String;
  problemTitle: String;
  ac: Int;
  wa: Int;
}

export interface ContestProblemPromise
  extends Promise<ContestProblem>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  problem: <T = ProblemPromise>() => T;
  problemId: () => Promise<String>;
  problemTitle: () => Promise<String>;
  ac: () => Promise<Int>;
  wa: () => Promise<Int>;
}

export interface ContestProblemSubscription
  extends Promise<AsyncIterator<ContestProblem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  problem: <T = ProblemSubscription>() => T;
  problemId: () => Promise<AsyncIterator<String>>;
  problemTitle: () => Promise<AsyncIterator<String>>;
  ac: () => Promise<AsyncIterator<Int>>;
  wa: () => Promise<AsyncIterator<Int>>;
}

export interface Problem {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  status: Int;
  type: Int;
  tags: Json;
  title: String;
  describe: String;
  inDescribe: String;
  outDescribe: String;
  inExample: String;
  outExample: String;
  hint?: String;
  source?: String;
  example?: String;
}

export interface ProblemPromise extends Promise<Problem>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  status: () => Promise<Int>;
  type: () => Promise<Int>;
  tags: () => Promise<Json>;
  title: () => Promise<String>;
  describe: () => Promise<String>;
  inDescribe: () => Promise<String>;
  outDescribe: () => Promise<String>;
  inExample: () => Promise<String>;
  outExample: () => Promise<String>;
  hint: () => Promise<String>;
  source: () => Promise<String>;
  example: () => Promise<String>;
  discuss: <T = FragmentableArray<Discuss>>(
    args?: {
      where?: DiscussWhereInput;
      orderBy?: DiscussOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProblemSubscription
  extends Promise<AsyncIterator<Problem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<Int>>;
  tags: () => Promise<AsyncIterator<Json>>;
  title: () => Promise<AsyncIterator<String>>;
  describe: () => Promise<AsyncIterator<String>>;
  inDescribe: () => Promise<AsyncIterator<String>>;
  outDescribe: () => Promise<AsyncIterator<String>>;
  inExample: () => Promise<AsyncIterator<String>>;
  outExample: () => Promise<AsyncIterator<String>>;
  hint: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  example: () => Promise<AsyncIterator<String>>;
  discuss: <T = Promise<AsyncIterator<DiscussSubscription>>>(
    args?: {
      where?: DiscussWhereInput;
      orderBy?: DiscussOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ContestConnection {
  pageInfo: PageInfo;
  edges: ContestEdge[];
}

export interface ContestConnectionPromise
  extends Promise<ContestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContestEdge>>() => T;
  aggregate: <T = AggregateContestPromise>() => T;
}

export interface ContestConnectionSubscription
  extends Promise<AsyncIterator<ContestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContestSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ContestEdge {
  node: Contest;
  cursor: String;
}

export interface ContestEdgePromise extends Promise<ContestEdge>, Fragmentable {
  node: <T = ContestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContestEdgeSubscription
  extends Promise<AsyncIterator<ContestEdge>>,
    Fragmentable {
  node: <T = ContestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContest {
  count: Int;
}

export interface AggregateContestPromise
  extends Promise<AggregateContest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContestSubscription
  extends Promise<AsyncIterator<AggregateContest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContestProblemConnection {
  pageInfo: PageInfo;
  edges: ContestProblemEdge[];
}

export interface ContestProblemConnectionPromise
  extends Promise<ContestProblemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContestProblemEdge>>() => T;
  aggregate: <T = AggregateContestProblemPromise>() => T;
}

export interface ContestProblemConnectionSubscription
  extends Promise<AsyncIterator<ContestProblemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContestProblemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContestProblemSubscription>() => T;
}

export interface ContestProblemEdge {
  node: ContestProblem;
  cursor: String;
}

export interface ContestProblemEdgePromise
  extends Promise<ContestProblemEdge>,
    Fragmentable {
  node: <T = ContestProblemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContestProblemEdgeSubscription
  extends Promise<AsyncIterator<ContestProblemEdge>>,
    Fragmentable {
  node: <T = ContestProblemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContestProblem {
  count: Int;
}

export interface AggregateContestProblemPromise
  extends Promise<AggregateContestProblem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContestProblemSubscription
  extends Promise<AsyncIterator<AggregateContestProblem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DiscussConnection {
  pageInfo: PageInfo;
  edges: DiscussEdge[];
}

export interface DiscussConnectionPromise
  extends Promise<DiscussConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DiscussEdge>>() => T;
  aggregate: <T = AggregateDiscussPromise>() => T;
}

export interface DiscussConnectionSubscription
  extends Promise<AsyncIterator<DiscussConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DiscussEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDiscussSubscription>() => T;
}

export interface DiscussEdge {
  node: Discuss;
  cursor: String;
}

export interface DiscussEdgePromise extends Promise<DiscussEdge>, Fragmentable {
  node: <T = DiscussPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DiscussEdgeSubscription
  extends Promise<AsyncIterator<DiscussEdge>>,
    Fragmentable {
  node: <T = DiscussSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDiscuss {
  count: Int;
}

export interface AggregateDiscussPromise
  extends Promise<AggregateDiscuss>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDiscussSubscription
  extends Promise<AsyncIterator<AggregateDiscuss>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DiscussChilderConnection {
  pageInfo: PageInfo;
  edges: DiscussChilderEdge[];
}

export interface DiscussChilderConnectionPromise
  extends Promise<DiscussChilderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DiscussChilderEdge>>() => T;
  aggregate: <T = AggregateDiscussChilderPromise>() => T;
}

export interface DiscussChilderConnectionSubscription
  extends Promise<AsyncIterator<DiscussChilderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DiscussChilderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDiscussChilderSubscription>() => T;
}

export interface DiscussChilderEdge {
  node: DiscussChilder;
  cursor: String;
}

export interface DiscussChilderEdgePromise
  extends Promise<DiscussChilderEdge>,
    Fragmentable {
  node: <T = DiscussChilderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DiscussChilderEdgeSubscription
  extends Promise<AsyncIterator<DiscussChilderEdge>>,
    Fragmentable {
  node: <T = DiscussChilderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDiscussChilder {
  count: Int;
}

export interface AggregateDiscussChilderPromise
  extends Promise<AggregateDiscussChilder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDiscussChilderSubscription
  extends Promise<AsyncIterator<AggregateDiscussChilder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PrivilegeGroupConnection {
  pageInfo: PageInfo;
  edges: PrivilegeGroupEdge[];
}

export interface PrivilegeGroupConnectionPromise
  extends Promise<PrivilegeGroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PrivilegeGroupEdge>>() => T;
  aggregate: <T = AggregatePrivilegeGroupPromise>() => T;
}

export interface PrivilegeGroupConnectionSubscription
  extends Promise<AsyncIterator<PrivilegeGroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PrivilegeGroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePrivilegeGroupSubscription>() => T;
}

export interface PrivilegeGroupEdge {
  node: PrivilegeGroup;
  cursor: String;
}

export interface PrivilegeGroupEdgePromise
  extends Promise<PrivilegeGroupEdge>,
    Fragmentable {
  node: <T = PrivilegeGroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PrivilegeGroupEdgeSubscription
  extends Promise<AsyncIterator<PrivilegeGroupEdge>>,
    Fragmentable {
  node: <T = PrivilegeGroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePrivilegeGroup {
  count: Int;
}

export interface AggregatePrivilegeGroupPromise
  extends Promise<AggregatePrivilegeGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePrivilegeGroupSubscription
  extends Promise<AsyncIterator<AggregatePrivilegeGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProblemConnection {
  pageInfo: PageInfo;
  edges: ProblemEdge[];
}

export interface ProblemConnectionPromise
  extends Promise<ProblemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProblemEdge>>() => T;
  aggregate: <T = AggregateProblemPromise>() => T;
}

export interface ProblemConnectionSubscription
  extends Promise<AsyncIterator<ProblemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProblemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProblemSubscription>() => T;
}

export interface ProblemEdge {
  node: Problem;
  cursor: String;
}

export interface ProblemEdgePromise extends Promise<ProblemEdge>, Fragmentable {
  node: <T = ProblemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProblemEdgeSubscription
  extends Promise<AsyncIterator<ProblemEdge>>,
    Fragmentable {
  node: <T = ProblemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProblem {
  count: Int;
}

export interface AggregateProblemPromise
  extends Promise<AggregateProblem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProblemSubscription
  extends Promise<AsyncIterator<AggregateProblem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Submit {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  userId: Int;
  userName: String;
  problemId: String;
  problemTitle: String;
  language: Int;
  code: String;
  result: String;
  errorInfo?: String;
  limitTime: Int;
  limitMemory: Int;
}

export interface SubmitPromise extends Promise<Submit>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  userId: () => Promise<Int>;
  userName: () => Promise<String>;
  problem: <T = ProblemPromise>() => T;
  problemId: () => Promise<String>;
  problemTitle: () => Promise<String>;
  language: () => Promise<Int>;
  code: () => Promise<String>;
  result: () => Promise<String>;
  errorInfo: () => Promise<String>;
  contest: <T = ContestPromise>() => T;
  limitTime: () => Promise<Int>;
  limitMemory: () => Promise<Int>;
}

export interface SubmitSubscription
  extends Promise<AsyncIterator<Submit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  userId: () => Promise<AsyncIterator<Int>>;
  userName: () => Promise<AsyncIterator<String>>;
  problem: <T = ProblemSubscription>() => T;
  problemId: () => Promise<AsyncIterator<String>>;
  problemTitle: () => Promise<AsyncIterator<String>>;
  language: () => Promise<AsyncIterator<Int>>;
  code: () => Promise<AsyncIterator<String>>;
  result: () => Promise<AsyncIterator<String>>;
  errorInfo: () => Promise<AsyncIterator<String>>;
  contest: <T = ContestSubscription>() => T;
  limitTime: () => Promise<AsyncIterator<Int>>;
  limitMemory: () => Promise<AsyncIterator<Int>>;
}

export interface SubmitConnection {
  pageInfo: PageInfo;
  edges: SubmitEdge[];
}

export interface SubmitConnectionPromise
  extends Promise<SubmitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubmitEdge>>() => T;
  aggregate: <T = AggregateSubmitPromise>() => T;
}

export interface SubmitConnectionSubscription
  extends Promise<AsyncIterator<SubmitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubmitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubmitSubscription>() => T;
}

export interface SubmitEdge {
  node: Submit;
  cursor: String;
}

export interface SubmitEdgePromise extends Promise<SubmitEdge>, Fragmentable {
  node: <T = SubmitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubmitEdgeSubscription
  extends Promise<AsyncIterator<SubmitEdge>>,
    Fragmentable {
  node: <T = SubmitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSubmit {
  count: Int;
}

export interface AggregateSubmitPromise
  extends Promise<AggregateSubmit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubmitSubscription
  extends Promise<AsyncIterator<AggregateSubmit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserGroupConnection {
  pageInfo: PageInfo;
  edges: UserGroupEdge[];
}

export interface UserGroupConnectionPromise
  extends Promise<UserGroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserGroupEdge>>() => T;
  aggregate: <T = AggregateUserGroupPromise>() => T;
}

export interface UserGroupConnectionSubscription
  extends Promise<AsyncIterator<UserGroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserGroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserGroupSubscription>() => T;
}

export interface UserGroupEdge {
  node: UserGroup;
  cursor: String;
}

export interface UserGroupEdgePromise
  extends Promise<UserGroupEdge>,
    Fragmentable {
  node: <T = UserGroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserGroupEdgeSubscription
  extends Promise<AsyncIterator<UserGroupEdge>>,
    Fragmentable {
  node: <T = UserGroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserGroup {
  count: Int;
}

export interface AggregateUserGroupPromise
  extends Promise<AggregateUserGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserGroupSubscription
  extends Promise<AsyncIterator<AggregateUserGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ContestSubscriptionPayload {
  mutation: MutationType;
  node: Contest;
  updatedFields: String[];
  previousValues: ContestPreviousValues;
}

export interface ContestSubscriptionPayloadPromise
  extends Promise<ContestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContestPreviousValuesPromise>() => T;
}

export interface ContestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContestPreviousValuesSubscription>() => T;
}

export interface ContestPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  type?: Int;
  createUserName: String;
  createUserId: Int;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
}

export interface ContestPreviousValuesPromise
  extends Promise<ContestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  type: () => Promise<Int>;
  createUserName: () => Promise<String>;
  createUserId: () => Promise<Int>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
}

export interface ContestPreviousValuesSubscription
  extends Promise<AsyncIterator<ContestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<Int>>;
  createUserName: () => Promise<AsyncIterator<String>>;
  createUserId: () => Promise<AsyncIterator<Int>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ContestProblemSubscriptionPayload {
  mutation: MutationType;
  node: ContestProblem;
  updatedFields: String[];
  previousValues: ContestProblemPreviousValues;
}

export interface ContestProblemSubscriptionPayloadPromise
  extends Promise<ContestProblemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContestProblemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContestProblemPreviousValuesPromise>() => T;
}

export interface ContestProblemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContestProblemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContestProblemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContestProblemPreviousValuesSubscription>() => T;
}

export interface ContestProblemPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  problemId: String;
  problemTitle: String;
  ac: Int;
  wa: Int;
}

export interface ContestProblemPreviousValuesPromise
  extends Promise<ContestProblemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  problemId: () => Promise<String>;
  problemTitle: () => Promise<String>;
  ac: () => Promise<Int>;
  wa: () => Promise<Int>;
}

export interface ContestProblemPreviousValuesSubscription
  extends Promise<AsyncIterator<ContestProblemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  problemId: () => Promise<AsyncIterator<String>>;
  problemTitle: () => Promise<AsyncIterator<String>>;
  ac: () => Promise<AsyncIterator<Int>>;
  wa: () => Promise<AsyncIterator<Int>>;
}

export interface DiscussSubscriptionPayload {
  mutation: MutationType;
  node: Discuss;
  updatedFields: String[];
  previousValues: DiscussPreviousValues;
}

export interface DiscussSubscriptionPayloadPromise
  extends Promise<DiscussSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DiscussPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DiscussPreviousValuesPromise>() => T;
}

export interface DiscussSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DiscussSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DiscussSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DiscussPreviousValuesSubscription>() => T;
}

export interface DiscussPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  contentRaw: String;
  content: String;
  userId: Int;
  userName: String;
}

export interface DiscussPreviousValuesPromise
  extends Promise<DiscussPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  contentRaw: () => Promise<String>;
  content: () => Promise<String>;
  userId: () => Promise<Int>;
  userName: () => Promise<String>;
}

export interface DiscussPreviousValuesSubscription
  extends Promise<AsyncIterator<DiscussPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  contentRaw: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<Int>>;
  userName: () => Promise<AsyncIterator<String>>;
}

export interface DiscussChilderSubscriptionPayload {
  mutation: MutationType;
  node: DiscussChilder;
  updatedFields: String[];
  previousValues: DiscussChilderPreviousValues;
}

export interface DiscussChilderSubscriptionPayloadPromise
  extends Promise<DiscussChilderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DiscussChilderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DiscussChilderPreviousValuesPromise>() => T;
}

export interface DiscussChilderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DiscussChilderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DiscussChilderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DiscussChilderPreviousValuesSubscription>() => T;
}

export interface DiscussChilderPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  contentRaw: String;
  content: String;
  userId: Int;
  userName: String;
  replyUserId: Int;
  replyUserName: String;
}

export interface DiscussChilderPreviousValuesPromise
  extends Promise<DiscussChilderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  contentRaw: () => Promise<String>;
  content: () => Promise<String>;
  userId: () => Promise<Int>;
  userName: () => Promise<String>;
  replyUserId: () => Promise<Int>;
  replyUserName: () => Promise<String>;
}

export interface DiscussChilderPreviousValuesSubscription
  extends Promise<AsyncIterator<DiscussChilderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  contentRaw: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<Int>>;
  userName: () => Promise<AsyncIterator<String>>;
  replyUserId: () => Promise<AsyncIterator<Int>>;
  replyUserName: () => Promise<AsyncIterator<String>>;
}

export interface PrivilegeGroupSubscriptionPayload {
  mutation: MutationType;
  node: PrivilegeGroup;
  updatedFields: String[];
  previousValues: PrivilegeGroupPreviousValues;
}

export interface PrivilegeGroupSubscriptionPayloadPromise
  extends Promise<PrivilegeGroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PrivilegeGroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PrivilegeGroupPreviousValuesPromise>() => T;
}

export interface PrivilegeGroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PrivilegeGroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PrivilegeGroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PrivilegeGroupPreviousValuesSubscription>() => T;
}

export interface PrivilegeGroupPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  privilege: Int;
}

export interface PrivilegeGroupPreviousValuesPromise
  extends Promise<PrivilegeGroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  privilege: () => Promise<Int>;
}

export interface PrivilegeGroupPreviousValuesSubscription
  extends Promise<AsyncIterator<PrivilegeGroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  privilege: () => Promise<AsyncIterator<Int>>;
}

export interface ProblemSubscriptionPayload {
  mutation: MutationType;
  node: Problem;
  updatedFields: String[];
  previousValues: ProblemPreviousValues;
}

export interface ProblemSubscriptionPayloadPromise
  extends Promise<ProblemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProblemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProblemPreviousValuesPromise>() => T;
}

export interface ProblemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProblemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProblemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProblemPreviousValuesSubscription>() => T;
}

export interface ProblemPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  status: Int;
  type: Int;
  tags: Json;
  title: String;
  describe: String;
  inDescribe: String;
  outDescribe: String;
  inExample: String;
  outExample: String;
  hint?: String;
  source?: String;
  example?: String;
}

export interface ProblemPreviousValuesPromise
  extends Promise<ProblemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  status: () => Promise<Int>;
  type: () => Promise<Int>;
  tags: () => Promise<Json>;
  title: () => Promise<String>;
  describe: () => Promise<String>;
  inDescribe: () => Promise<String>;
  outDescribe: () => Promise<String>;
  inExample: () => Promise<String>;
  outExample: () => Promise<String>;
  hint: () => Promise<String>;
  source: () => Promise<String>;
  example: () => Promise<String>;
}

export interface ProblemPreviousValuesSubscription
  extends Promise<AsyncIterator<ProblemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<Int>>;
  tags: () => Promise<AsyncIterator<Json>>;
  title: () => Promise<AsyncIterator<String>>;
  describe: () => Promise<AsyncIterator<String>>;
  inDescribe: () => Promise<AsyncIterator<String>>;
  outDescribe: () => Promise<AsyncIterator<String>>;
  inExample: () => Promise<AsyncIterator<String>>;
  outExample: () => Promise<AsyncIterator<String>>;
  hint: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  example: () => Promise<AsyncIterator<String>>;
}

export interface SubmitSubscriptionPayload {
  mutation: MutationType;
  node: Submit;
  updatedFields: String[];
  previousValues: SubmitPreviousValues;
}

export interface SubmitSubscriptionPayloadPromise
  extends Promise<SubmitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubmitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubmitPreviousValuesPromise>() => T;
}

export interface SubmitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubmitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubmitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubmitPreviousValuesSubscription>() => T;
}

export interface SubmitPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  userId: Int;
  userName: String;
  problemId: String;
  problemTitle: String;
  language: Int;
  code: String;
  result: String;
  errorInfo?: String;
  limitTime: Int;
  limitMemory: Int;
}

export interface SubmitPreviousValuesPromise
  extends Promise<SubmitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<Int>;
  userName: () => Promise<String>;
  problemId: () => Promise<String>;
  problemTitle: () => Promise<String>;
  language: () => Promise<Int>;
  code: () => Promise<String>;
  result: () => Promise<String>;
  errorInfo: () => Promise<String>;
  limitTime: () => Promise<Int>;
  limitMemory: () => Promise<Int>;
}

export interface SubmitPreviousValuesSubscription
  extends Promise<AsyncIterator<SubmitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<Int>>;
  userName: () => Promise<AsyncIterator<String>>;
  problemId: () => Promise<AsyncIterator<String>>;
  problemTitle: () => Promise<AsyncIterator<String>>;
  language: () => Promise<AsyncIterator<Int>>;
  code: () => Promise<AsyncIterator<String>>;
  result: () => Promise<AsyncIterator<String>>;
  errorInfo: () => Promise<AsyncIterator<String>>;
  limitTime: () => Promise<AsyncIterator<Int>>;
  limitMemory: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  userId: Int;
  password: String;
  level: Int;
  name: String;
  email?: String;
  problems: Json[];
  submit: Int;
  solved: Int;
  accepted: Int;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<Int>;
  password: () => Promise<String>;
  level: () => Promise<Int>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  problems: () => Promise<Json[]>;
  submit: () => Promise<Int>;
  solved: () => Promise<Int>;
  accepted: () => Promise<Int>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<Int>>;
  password: () => Promise<AsyncIterator<String>>;
  level: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  problems: () => Promise<AsyncIterator<Json[]>>;
  submit: () => Promise<AsyncIterator<Int>>;
  solved: () => Promise<AsyncIterator<Int>>;
  accepted: () => Promise<AsyncIterator<Int>>;
}

export interface UserGroupSubscriptionPayload {
  mutation: MutationType;
  node: UserGroup;
  updatedFields: String[];
  previousValues: UserGroupPreviousValues;
}

export interface UserGroupSubscriptionPayloadPromise
  extends Promise<UserGroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserGroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserGroupPreviousValuesPromise>() => T;
}

export interface UserGroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserGroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserGroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserGroupPreviousValuesSubscription>() => T;
}

export interface UserGroupPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface UserGroupPreviousValuesPromise
  extends Promise<UserGroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface UserGroupPreviousValuesSubscription
  extends Promise<AsyncIterator<UserGroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Json = any;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "PrivilegeGroup",
    embedded: false
  },
  {
    name: "UserGroup",
    embedded: false
  },
  {
    name: "Problem",
    embedded: false
  },
  {
    name: "Discuss",
    embedded: false
  },
  {
    name: "DiscussChilder",
    embedded: false
  },
  {
    name: "Submit",
    embedded: false
  },
  {
    name: "Contest",
    embedded: false
  },
  {
    name: "ContestProblem",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://vm.vm:4466/pdsuoj`
});
export const prisma = new Prisma();
